<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>处理日志 - Sorryios AI</title>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            if (window.self !== window.top) {
                // 强制重置 - 去掉所有边距
                document.documentElement.style.cssText = 'margin: 0 !important; padding: 0 !important; width: 100% !important;';
                document.body.classList.add('in-iframe');
                document.body.style.cssText = 'padding: 0 !important; margin: 0 !important; width: 100% !important; min-width: 0 !important;';
                
                const container = document.querySelector('.container');
                if (container) {
                    container.style.cssText = 'max-width: none !important; width: 100% !important; margin: 0 !important; padding: 10px !important; min-width: 0 !important;';
                }
                
                const backLink = document.querySelector('.back-link');
                if (backLink) backLink.style.display = 'none';
                
                console.log('[处理日志] iframe模式已激活');
            }
        });
    </script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #f7f7f8; 
            min-height: 100vh; 
            padding: 20px; 
        }
        
        /* iframe内嵌时的样式 - 完全适配 */
        body.in-iframe {
            padding: 12px !important;
            margin: 0 !important;
            overflow-x: hidden;
        }
        body.in-iframe .back-link {
            display: none !important;
        }
        body.in-iframe .container {
            width: 100% !important;
            max-width: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
        body.in-iframe .header {
            padding: 16px !important;
            margin-bottom: 12px !important;
        }
        body.in-iframe .header h1 {
            font-size: 20px !important;
        }
        body.in-iframe .three-columns {
            gap: 10px !important;
        }
        body.in-iframe .column {
            min-width: 280px !important;
        }
        body.in-iframe .column-header {
            padding: 12px !important;
        }
        body.in-iframe .column-body {
            padding: 8px !important;
        }
        
        .container { max-width: 1400px; margin: 0 auto; }
        
        /* 返回链接 */
        .back-link { 
            display: inline-flex; 
            align-items: center; 
            gap: 6px; 
            color: #666; 
            text-decoration: none; 
            margin-bottom: 16px; 
            font-weight: 500;
            font-size: 14px;
        }
        .back-link:hover { color: #1a1a1a; }
        
        /* 头部 */
        .header { 
            background: white; 
            border-radius: 12px; 
            padding: 24px; 
            margin-bottom: 20px; 
            border: 1px solid #e5e5e5; 
        }
        .header-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 16px;
            flex-wrap: wrap;
        }
        .header h1 { color: #1a1a1a; font-size: 26px; margin-bottom: 8px; }
        .header p { color: #666; font-size: 14px; }
        
        /* 统计卡片 */
        .stats-row { 
            display: grid; 
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); 
            gap: 16px; 
            margin-top: 20px; 
        }
        .stat-card {
            background: #f9fafb;
            border-radius: 12px;
            padding: 16px 20px;
            border: 1px solid #e5e5e5;
        }
        .stat-card .label { font-size: 13px; color: #6b7280; margin-bottom: 4px; }
        .stat-card .value { font-size: 28px; font-weight: 700; color: #1a1a1a; }
        .stat-card .sub { font-size: 12px; color: #9ca3af; margin-top: 4px; }
        
        /* 标签页 */
        .tabs { 
            background: white; 
            border-radius: 12px; 
            padding: 6px; 
            margin-bottom: 20px; 
            display: flex; 
            gap: 6px;
            border: 1px solid #e5e5e5;
        }
        .tab-btn { 
            flex: 1; 
            padding: 12px 20px; 
            border: none; 
            border-radius: 8px; 
            font-size: 14px; 
            font-weight: 600; 
            cursor: pointer; 
            transition: all 0.2s; 
            background: transparent; 
            color: #6b7280; 
        }
        .tab-btn:hover { background: #f3f4f6; color: #1a1a1a; }
        .tab-btn.active { 
            background: #f3f4f6; 
            color: #1a1a1a; 
            border: 1px solid #d1d5db;
        }
        .tab-btn .badge {
            display: inline-block;
            background: #e5e7eb;
            color: #374151;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 10px;
            margin-left: 6px;
        }
        .tab-btn.active .badge {
            background: #d1d5db;
            color: #1a1a1a;
        }
        
        /* 内容区 */
        .tab-content { display: none; }
        .tab-content.active { display: block; }
        
        /* 列表容器 */
        .list-container {
            background: white;
            border-radius: 12px;
            border: 1px solid #e5e5e5;
            overflow: hidden;
        }
        
        /* 工具栏 */
        .toolbar {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }
        .toolbar .title {
            font-weight: 600;
            color: #1a1a1a;
            font-size: 15px;
        }
        .toolbar .spacer { flex: 1; }
        
        /* 按钮样式 - 线条风格 */
        .btn {
            padding: 8px 16px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
            background: white;
            color: #374151;
        }
        .btn:hover { background: #f9fafb; border-color: #9ca3af; }
        .btn-primary { background: white; color: #2563eb; border: 1px solid #93c5fd; }
        .btn-primary:hover { background: #eff6ff; border-color: #60a5fa; }
        .btn-success { background: white; color: #059669; border: 1px solid #a7f3d0; }
        .btn-success:hover { background: #ecfdf5; border-color: #34d399; }
        .btn-danger { background: white; color: #dc2626; border: 1px solid #fecaca; }
        .btn-danger:hover { background: #fef2f2; border-color: #f87171; }
        .btn-secondary { background: white; color: #374151; border: 1px solid #d1d5db; }
        .btn-secondary:hover { background: #f9fafb; border-color: #9ca3af; }
        .btn-sm { padding: 5px 10px; font-size: 12px; }
        
        /* 危险按钮 - 清空数据专用 */
        .btn-danger-outline {
            background: transparent;
            color: #dc2626;
            border: 1px solid #fecaca;
        }
        .btn-danger-outline:hover {
            background: #fef2f2;
            border-color: #f87171;
        }
        
        /* 任务卡片 */
        .task-card {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
            cursor: pointer;
            transition: background 0.2s;
        }
        .task-card:hover { background: #f9fafb; }
        .task-card:last-child { border-bottom: none; }
        .task-card .task-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        .task-card .task-id {
            font-family: monospace;
            font-size: 13px;
            color: #374151;
            background: #f3f4f6;
            padding: 2px 8px;
            border-radius: 4px;
        }
        .task-card .task-user {
            font-weight: 500;
            color: #1e293b;
        }
        .task-card .task-time {
            font-size: 12px;
            color: #94a3b8;
        }
        .task-card .task-file {
            font-size: 13px;
            color: #64748b;
            margin-bottom: 8px;
        }
        .task-card .task-stats {
            display: flex;
            gap: 16px;
            font-size: 12px;
        }
        .task-card .task-stats .exact { color: #059669; }
        .task-card .task-stats .fuzzy { color: #d97706; }
        .task-card .task-stats .unmatched { color: #dc2626; }
        
        /* 匹配项卡片 */
        .match-item {
            padding: 16px 20px;
            border-bottom: 1px solid #fef3c7;
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }
        .match-item:last-child { border-bottom: none; }
        .match-item:hover { background: #f9fafb; }
        .item-icon {
            width: 36px;
            height: 36px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            flex-shrink: 0;
        }
        .item-icon.exact { background: #d1fae5; }
        .item-icon.fuzzy { background: #e5e7eb; }
        .item-icon.unmatched { background: #fee2e2; }
        .item-content { flex: 1; min-width: 0; }
        .item-original {
            font-weight: 600;
            color: #1e293b;
            margin-bottom: 4px;
            word-break: break-word;
        }
        .item-matched {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            font-size: 13px;
        }
        .item-matched .arrow { color: #9ca3af; }
        .item-matched .matched-text { color: #059669; font-weight: 500; }
        .item-matched .score {
            background: #f3f4f6;
            color: #374151;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 11px;
        }
        .item-type {
            background: #e5e7eb;
            color: #374151;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        .item-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }
        
        /* v4.4.0 新增：子话题相关样式 */
        .subtopic-arrow {
            color: #9ca3af;
            margin: 0 4px;
        }
        .subtopic-highlight {
            color: #e74c3c;
            font-weight: bold;
            background: #ffe5e5;
            padding: 2px 6px;
            border-radius: 4px;
        }
        .knowledge-system {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
            border-left: 3px solid #1976d2;
        }
        .main-topic-section {
            padding: 10px;
            background: white;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .section-title {
            font-weight: bold;
            color: #1976d2;
            margin-bottom: 8px;
            font-size: 13px;
        }
        .knowledge-system .field {
            margin-bottom: 6px;
            font-size: 12px;
            line-height: 1.5;
        }
        .knowledge-system .field label {
            color: #666;
            font-weight: 500;
            margin-right: 6px;
        }
        .knowledge-system .field code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .subtopics-section {
            padding: 10px;
            background: white;
            border-radius: 6px;
        }
        .subtopic-item {
            padding: 10px;
            margin-bottom: 8px;
            border-radius: 6px;
            background: #fafafa;
            border-left: 3px solid #e0e0e0;
        }
        .subtopic-item.hit {
            background: #ffe5e5;
            border-left-color: #e74c3c;
        }
        .subtopic-header {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 6px;
        }
        .subtopic-icon {
            font-size: 12px;
        }
        .subtopic-name {
            font-weight: bold;
            color: #333;
            font-size: 13px;
        }
        .subtopic-item.hit .subtopic-name {
            color: #e74c3c;
        }
        .hit-badge {
            background: #e74c3c;
            color: white;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
        }
        .subtopic-field {
            margin-left: 20px;
            font-size: 12px;
            color: #555;
            margin-bottom: 4px;
        }
        .subtopic-field label {
            color: #777;
            font-weight: 500;
            margin-right: 4px;
        }
        .subtopic-field code {
            background: #f5f5f5;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        .array-item {
            display: inline-block;
            margin-right: 4px;
            padding: 2px 0;
        }
        .array-item:not(:last-child)::after {
            content: ';';
            margin-right: 4px;
            color: #999;
        }
        
        /* AI 生成内容 */
        .item-ai-content {
            margin-top: 8px;
            background: #f8fafc;
            border-radius: 6px;
            padding: 10px;
            font-size: 12px;
        }
        .ai-label {
            color: #6b7280;
            font-weight: 500;
            margin-bottom: 4px;
        }
        
        /* 状态徽章 */
        .status-badge {
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        .status-badge.pending { background: #f3f4f6; color: #374151; }
        .status-badge.edited { background: #dbeafe; color: #1e40af; }
        .status-badge.imported { background: #d1fae5; color: #065f46; }
        .status-badge.ignored { background: #e5e7eb; color: #374151; }
        
        /* 空状态 */
        .empty-state {
            padding: 60px 20px;
            text-align: center;
            color: #94a3b8;
        }
        .empty-state h3 { font-size: 18px; margin-bottom: 8px; color: #64748b; }
        
        /* 加载状态 */
        .loading {
            padding: 40px 20px;
            text-align: center;
            color: #94a3b8;
        }
        
        /* 弹窗 */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }
        .modal.active { display: flex; }
        .modal-content {
            background: white;
            border-radius: 16px;
            width: 100%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0,0,0,0.2);
        }
        .modal-header {
            padding: 20px;
            border-bottom: 1px solid #e5e5e5;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .modal-header h2 { font-size: 18px; color: #78350f; }
        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #94a3b8;
            cursor: pointer;
        }
        .modal-close:hover { color: #64748b; }
        .modal-body { padding: 20px; }
        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #fef3c7;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        
        /* 表单 */
        .form-group { margin-bottom: 16px; }
        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            color: #374151;
            margin-bottom: 6px;
        }
        .form-group input,
        .form-group textarea,
        .form-group select {
            width: 100%;
            padding: 10px 12px;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.2s;
        }
        .form-group input:focus,
        .form-group textarea:focus,
        .form-group select:focus {
            outline: none;
            border-color: #f59e0b;
        }
        .form-group textarea { min-height: 80px; resize: vertical; }
        
        /* 信息块 */
        .info-block {
            background: #fef3c7;
            border-radius: 8px;
            padding: 12px 16px;
            margin-bottom: 16px;
        }
        .info-label {
            font-size: 11px;
            color: #92400e;
            text-transform: uppercase;
        }
        .info-value {
            font-weight: 500;
            color: #78350f;
        }
        
        /* Toast */
        .toast {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%) translateY(100px);
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            transition: transform 0.3s ease;
            z-index: 2000;
        }
        .toast.success { background: #10b981; color: white; }
        .toast.error { background: #ef4444; color: white; }
        .toast.show { transform: translateX(-50%) translateY(0); }
        
        /* 清空确认弹窗 */
        .clear-confirm-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ef4444;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            margin-top: 16px;
        }
        .clear-confirm-input:focus {
            outline: none;
            border-color: #dc2626;
        }
        .clear-warning {
            background: #fef2f2;
            border: 1px solid #fecaca;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 16px;
        }
        .clear-warning h4 {
            color: #dc2626;
            margin-bottom: 8px;
        }
        .clear-warning p {
            color: #7f1d1d;
            font-size: 14px;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="/admin" class="back-link">← 返回管理后台</a>
        
        <div class="header">
            <div class="header-top">
                <div>
                    <h1>📋 处理日志</h1>
                    <p>AI 处理结果的审核与管理</p>
                </div>
                <button class="btn btn-danger-outline" onclick="openClearModal()">🗑️ 清空数据</button>
            </div>
            
            <div class="stats-row">
                <div class="stat-card">
                    <div class="label">今日任务</div>
                    <div class="value" id="statTodayTasks">0</div>
                    <div class="sub">处理的文件数</div>
                </div>
                <div class="stat-card">
                    <div class="label">模糊匹配</div>
                    <div class="value" id="statPendingMatches">0</div>
                    <div class="sub">85-99% 待审核</div>
                </div>
                <div class="stat-card">
                    <div class="label">AI 生成</div>
                    <div class="value" id="statPendingUnmatched">0</div>
                    <div class="sub">待完善入库</div>
                </div>
                <div class="stat-card">
                    <div class="label">今日入库</div>
                    <div class="value" id="statTodayImported">0</div>
                    <div class="sub">已入库数据</div>
                </div>
            </div>
        </div>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('tasks')">📜 历史记录</button>
            <button class="tab-btn" onclick="console.log('点击了100%匹配按钮'); switchTab('exact-matches');">
                ✅ 100%匹配
                <span class="badge" id="badgeExactMatches">0</span>
            </button>
            <button class="tab-btn" onclick="switchTab('pending-matches')">
                🟡 ﹥85%匹配
                <span class="badge" id="badgePendingMatches" style="display:none;">0</span>
            </button>
            <button class="tab-btn" onclick="switchTab('pending-unmatched')">
                🔴 ﹤85%匹配
                <span class="badge" id="badgePendingUnmatched" style="display:none;">0</span>
            </button>
        </div>
        
        <!-- 处理任务 -->
        <div class="tab-content active" id="tab-tasks">
            <div class="list-container">
                <div class="toolbar">
                    <span class="title">📜 历史记录列表</span>
                    <span class="spacer"></span>
                    <button class="btn btn-secondary" onclick="loadTasks()">🔄 刷新</button>
                </div>
                <div id="tasksList">
                    <div class="loading">加载中...</div>
                </div>
            </div>
        </div>
        
        <!-- 待审核匹配 -->
        <div class="tab-content" id="tab-pending-matches">
            <div class="list-container">
                <div class="toolbar">
                    <span class="title">🟡 ﹥85%匹配列表</span>
                    <span class="spacer"></span>
                    <button class="btn btn-success" onclick="confirmAllMatches()">✓ 全部确认</button>
                    <button class="btn btn-secondary" onclick="loadPendingMatches()">🔄 刷新</button>
                </div>
                <div style="padding:12px 20px; background:#fffbeb; border-bottom:1px solid #fef3c7;">
                    <div style="font-size:13px; color:#b45309; line-height:1.6;">
                        <strong>💡 说明：</strong>AI提取的内容与词库部分匹配（相似度85%-99%），需要人工审核。确认后将保存匹配规则，下次自动识别为100%匹配。
                    </div>
                </div>
                <div id="pendingMatchesList">
                    <div class="loading">加载中...</div>
                </div>
            </div>
        </div>
        
        <!-- 待完善入库 -->
        <div class="tab-content" id="tab-pending-unmatched">
            <div class="list-container">
                <div class="toolbar">
                    <span class="title">🔴 ﹤85%匹配列表</span>
                    <span class="spacer"></span>
                    <button class="btn btn-secondary" onclick="loadPendingUnmatched()">🔄 刷新</button>
                </div>
                <div style="padding:12px 20px; background:#fef2f2; border-bottom:1px solid #fecaca;">
                    <div style="font-size:13px; color:#b91c1c; line-height:1.6;">
                        <strong>💡 说明：</strong>AI提取的内容与词库匹配度低（相似度﹤85%），由AI自动生成释义。请编辑完善后入库，或直接替换为已有词条。
                    </div>
                </div>
                <div id="pendingUnmatchedList">
                    <div class="loading">加载中...</div>
                </div>
            </div>
        </div>
            
        <!-- 精准匹配内容区域 -->
        <div class="tab-content" id="tab-exact-matches">
            <div class="list-container">
                <div class="toolbar">
                    <span class="title">✅ 100%匹配列表</span>
                    <span class="spacer"></span>
                    <button class="btn btn-secondary" onclick="loadExactMatches()">🔄 刷新</button>
                </div>
                <div style="padding:12px 20px; background:#ecfdf5; border-bottom:1px solid #d1fae5;">
                    <div style="font-size:13px; color:#047857; line-height:1.6;">
                        <strong>💡 说明：</strong>AI提取的内容与词库完全匹配（相似度=100%），自动通过无需审核。这些记录已成功识别并可直接使用。
                    </div>
                </div>
                <div id="exactMatchesContainer">
                    <div class="loading">加载中...</div>
                </div>
            </div>
        </div>

    </div>
        </div>
    </div>
    
    <!-- 编辑弹窗 -->
    <div class="modal" id="editModal">
        <div class="modal-content" style="max-width: 620px;">
            <div class="modal-header">
                <h2>✎ 编辑数据</h2>
                <button class="modal-close" onclick="closeModal('editModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="editItemId">
                <input type="hidden" id="editItemType">
                
                <div class="info-block">
                    <span class="info-label">原始文本</span>
                    <div class="info-value" id="editOriginalText"></div>
                </div>
                
                <div class="form-group">
                    <label>目标类型</label>
                    <select id="editTargetType">
                        <option value="word">单词</option>
                        <option value="phrase">短语</option>
                        <option value="pattern">句型</option>
                        <option value="grammar">语法</option>
                    </select>
                </div>
                
                <div class="form-group">
                    <label>分类</label>
                    <input type="text" id="editCategory" placeholder="如：动词短语、名词、现在时态...">
                </div>
                
                <!-- 词汇类字段 -->
                <div id="vocabFields">
                    <div class="form-group">
                        <label>音标</label>
                        <input type="text" id="editPhonetic" placeholder="如：/ˈæp.əl/">
                    </div>
                    <div class="form-group">
                        <label>词性</label>
                        <input type="text" id="editPos" placeholder="如：n. / v. / adj.">
                    </div>
                    <div class="form-group">
                        <label>含义</label>
                        <textarea id="editMeaning" placeholder="中文释义"></textarea>
                    </div>
                    <div class="form-group">
                        <label>例句</label>
                        <textarea id="editExample" placeholder="英文例句"></textarea>
                    </div>
                </div>
                
                <!-- 语法类字段 -->
                <div id="grammarFields" style="display:none;">
                    <div class="form-group">
                        <label>定义</label>
                        <textarea id="editDefinition" placeholder="语法点定义"></textarea>
                    </div>
                    <div class="form-group">
                        <label>结构</label>
                        <textarea id="editStructure" placeholder="语法结构"></textarea>
                    </div>
                    <div class="form-group">
                        <label>用法</label>
                        <textarea id="editUsage" placeholder="多个用法用换行分隔"></textarea>
                    </div>
                    <div class="form-group">
                        <label>例句</label>
                        <textarea id="editExamples" placeholder="多个例句用换行分隔"></textarea>
                    </div>
                    <div class="form-group">
                        <label>易错点</label>
                        <textarea id="editMistakes" placeholder="多个易错点用换行分隔"></textarea>
                    </div>
                </div>
            </div>
            <div class="modal-footer" style="justify-content: space-between; padding: 12px 16px;">
                <!-- v7.0 简化按钮布局：删除排除按钮 -->
                <div style="display: flex; gap: 10px;">
                    <button class="btn" id="matchBtn" onclick="openMatchModal()" style="padding: 10px 20px; font-size: 14px; font-weight: 600; color: #d97706; border-color: #fcd34d; background: #fffbeb;">🔄 替换</button>
                    <button class="btn" id="toGrammarBtn" onclick="openToGrammarModal()" style="padding: 10px 20px; font-size: 14px; font-weight: 600; color: #7c3aed; border-color: #c4b5fd; background: #f5f3ff;">📗 转语法</button>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="btn" onclick="saveAndImport()" style="padding: 10px 20px; font-size: 14px; font-weight: 600; color: #059669; border-color: #a7f3d0; background: #ecfdf5;">💾 保存</button>
                    <button class="btn btn-secondary" onclick="closeModal('editModal')" style="padding: 10px 16px; font-size: 14px;">取消</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- 任务详情弹窗 -->
    <div class="modal" id="taskDetailModal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>任务详情</h2>
                <button class="modal-close" onclick="closeModal('taskDetailModal')">&times;</button>
            </div>
            <div class="modal-body" id="taskDetailContent">
                <div class="loading">加载中...</div>
            </div>
        </div>
    </div>
    
    <!-- 清空数据确认弹窗 -->
    <div class="modal" id="clearModal">
        <div class="modal-content" style="max-width: 450px;">
            <div class="modal-header">
                <h2>⚠️ 清空所有数据</h2>
                <button class="modal-close" onclick="closeModal('clearModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="clear-warning">
                    <h4>⚠️ 危险操作！</h4>
                    <p>此操作将清空以下所有数据：</p>
                    <ul style="margin: 10px 0 0 20px; font-size: 14px; color: #7f1d1d;">
                        <li>所有待审核的模糊匹配记录</li>
                        <li>所有待完善入库的数据</li>
                        <li>所有已处理的匹配记录</li>
                    </ul>
                    <p style="margin-top: 12px; font-weight: 600;">此操作不可撤销！</p>
                </div>
                
                <p style="text-align: center; color: #64748b; margin-bottom: 8px;">请输入 <strong style="color: #dc2626;">确认清除</strong> 以继续</p>
                <input type="text" class="clear-confirm-input" id="clearConfirmInput" placeholder="请输入：确认清除">
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('clearModal')">取消</button>
                <button class="btn btn-danger" onclick="executeClear()">🗑️ 清空数据</button>
            </div>
        </div>
    </div>
    
    <!-- v3.0: 标记错误弹窗 -->
    <div class="modal" id="rejectModal">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h2>❌ 标记匹配错误</h2>
                <button class="modal-close" onclick="closeModal('rejectModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="rejectMatchId">
                <input type="hidden" id="rejectOriginalText">
                <input type="hidden" id="rejectOriginalType">
                <input type="hidden" id="rejectMatchedText">
                <input type="hidden" id="rejectSourceDb">
                <input type="hidden" id="rejectSourceTable">
                <input type="hidden" id="rejectSourceId">
                
                <div class="info-block" style="background: #fef3c7; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #92400e; margin-bottom: 4px;">当前匹配</div>
                    <div style="font-size: 15px;">
                        <strong id="rejectDisplayOriginal"></strong> → 
                        <span id="rejectDisplayMatched" style="color: #dc2626;"></span>
                        <span id="rejectDisplayScore" style="color: #666; font-size: 12px;"></span>
                    </div>
                </div>
                
                <p style="font-weight: 600; color: #78350f; margin-bottom: 12px;">这个匹配有什么问题？</p>
                
                <div class="reject-options" style="display: flex; flex-direction: column; gap: 10px;">
                    <label class="reject-option" style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #f9fafb; border-radius: 8px; cursor: pointer; border: 2px solid transparent;">
                        <input type="radio" name="rejectAction" value="wrong" checked style="width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">匹配到错误的词条</div>
                            <div style="font-size: 12px; color: #666;">选择正确的词条，系统会记住</div>
                        </div>
                    </label>
                    
                    <label class="reject-option" style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #f9fafb; border-radius: 8px; cursor: pointer; border: 2px solid transparent;">
                        <input type="radio" name="rejectAction" value="exclude" style="width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;" id="rejectExcludeLabel">不是短语（识别错误）</div>
                            <div style="font-size: 12px; color: #666;">下次遇到会自动跳过</div>
                        </div>
                    </label>
                    
                    <label class="reject-option" style="display: flex; align-items: center; gap: 10px; padding: 12px; background: #f9fafb; border-radius: 8px; cursor: pointer; border: 2px solid transparent;">
                        <input type="radio" name="rejectAction" value="new" style="width: 18px; height: 18px;">
                        <div>
                            <div style="font-weight: 500;">新建词条</div>
                            <div style="font-size: 12px; color: #666;">词库里没有，需要新建</div>
                        </div>
                    </label>
                </div>
                
                <!-- 选择正确词条的区域（默认隐藏） -->
                <div id="correctMatchSection" style="margin-top: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px;">
                    <label style="display: block; font-size: 13px; color: #166534; margin-bottom: 8px; font-weight: 500;">请选择或输入正确的词条：</label>
                    <div style="position: relative;">
                        <input type="text" id="correctMatchSearch" placeholder="🔍 输入关键词搜索词库..." 
                            style="width: 100%; padding: 12px 12px 12px 12px; border: 2px solid #86efac; border-radius: 8px; font-size: 14px; box-sizing: border-box;"
                            oninput="searchVocabulary(this.value)">
                        <div id="searchLoading" style="display: none; position: absolute; right: 12px; top: 50%; transform: translateY(-50%); color: #22c55e;">搜索中...</div>
                    </div>
                    <div id="searchResultsContainer" style="margin-top: 8px; max-height: 200px; overflow-y: auto; border: 1px solid #86efac; border-radius: 8px; display: none;">
                        <!-- 搜索结果会动态填充到这里 -->
                    </div>
                    <input type="hidden" id="correctMatchSelect" value="">
                    <div id="selectedMatch" style="margin-top: 8px; padding: 10px; background: #dcfce7; border-radius: 6px; display: none;">
                        <span style="color: #166534; font-weight: 500;">✓ 已选择：</span>
                        <span id="selectedMatchText" style="color: #15803d;"></span>
                        <button onclick="clearSelectedMatch()" style="float: right; background: none; border: none; color: #dc2626; cursor: pointer; font-size: 12px;">✕ 清除</button>
                    </div>
                </div>
                
                <!-- v5.5 新增：新建词条的输入区域（默认隐藏） -->
                <div id="newEntrySection" style="margin-top: 16px; padding: 12px; background: #fef3c7; border-radius: 8px; display: none;">
                    <label style="display: block; font-size: 13px; color: #92400e; margin-bottom: 8px; font-weight: 500;">📝 新建词条</label>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #78350f; margin-bottom: 4px; display: block;">词条内容 <span style="color: #ef4444;">*</span></label>
                        <input type="text" id="newEntryText" placeholder="输入新词条..." style="width: 100%; padding: 10px; border: 1px solid #fcd34d; border-radius: 6px;">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #78350f; margin-bottom: 4px; display: block;">中文含义 <span style="color: #ef4444;">*</span></label>
                        <input type="text" id="newEntryMeaning" placeholder="输入中文含义..." style="width: 100%; padding: 10px; border: 1px solid #fcd34d; border-radius: 6px;">
                    </div>
                    <div style="margin-bottom: 10px;">
                        <label style="font-size: 12px; color: #78350f; margin-bottom: 4px; display: block;">例句（选填）</label>
                        <input type="text" id="newEntryExample" placeholder="输入例句..." style="width: 100%; padding: 10px; border: 1px solid #fcd34d; border-radius: 6px;">
                    </div>
                    <p style="font-size: 11px; color: #a16207; margin-top: 8px;">💡 创建后会自动建立匹配关系，下次遇到相同词会直接匹配到这个词条</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('rejectModal')">取消</button>
                <button class="btn btn-danger" onclick="executeReject()">确认</button>
            </div>
        </div>
    </div>
    
    <!-- v5.5 新增：排除弹窗（从编辑页面触发） -->
    <div class="modal" id="excludeModal">
        <div class="modal-content" style="max-width: 480px;">
            <div class="modal-header">
                <h2>🚫 排除识别错误</h2>
                <button class="modal-close" onclick="closeModal('excludeModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="excludeItemId">
                <input type="hidden" id="excludeOriginalText">
                <input type="hidden" id="excludeOriginalType">
                
                <div class="info-block" style="background: #fee2e2; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #991b1b; margin-bottom: 4px;">将被排除</div>
                    <div style="font-size: 16px; font-weight: 600; color: #7f1d1d;" id="excludeDisplayText"></div>
                    <div style="font-size: 12px; color: #991b1b; margin-top: 4px;" id="excludeDisplayType"></div>
                </div>
                
                <p style="font-size: 14px; color: #374151; margin-bottom: 12px;">
                    排除后，下次遇到 <strong id="excludeDisplayText2"></strong> 时会自动跳过，不再识别为<span id="excludeDisplayType2"></span>。
                </p>
                
                <div style="background: #f0fdf4; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-weight: 500; color: #166534; margin-bottom: 8px;">📝 提取单词入库（可选）</div>
                    <div style="font-size: 12px; color: #15803d; margin-bottom: 12px;">勾选需要提取的单词，已在词库中的会自动跳过</div>
                    <div id="extractWordCheckboxes" style="display: flex; flex-wrap: wrap; gap: 8px;">
                        <!-- 动态生成的checkbox列表 -->
                    </div>
                    <div id="noWordsToExtract" style="display: none; color: #64748b; font-size: 13px; padding: 8px 0;">
                        没有可提取的单词
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('excludeModal')">取消</button>
                <button class="btn btn-danger" onclick="executeExcludeFromEdit()">🚫 确认排除</button>
            </div>
        </div>
    </div>

    <!-- v5.7 新增：替换弹窗（识别错误时使用） -->
    <div class="modal" id="replaceModal">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);">
                <h2 style="color: #1e40af;">🔄 识别错误 - 设置替换规则</h2>
                <button class="modal-close" onclick="closeModal('replaceModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="replaceItemId">
                <input type="hidden" id="replaceItemType">

                <div style="background: #fee2e2; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #991b1b; margin-bottom: 4px;">原始文本（识别错误的）</div>
                    <div style="font-size: 16px; font-weight: 600; color: #7f1d1d;" id="replaceOriginalText"></div>
                </div>

                <div class="form-group">
                    <label style="color: #1e40af; font-weight: 600;">替换为（正确的文本） <span style="color:#ef4444">*</span></label>
                    <input type="text" id="replaceNewText" placeholder="输入正确的文本，如：be important to" style="border-color: #3b82f6;">
                </div>

                <div id="replacePreview" style="display: none; background: #f0fdf4; padding: 12px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #166534; margin-bottom: 4px;">📋 词库匹配预览</div>
                    <div id="replacePreviewContent" style="font-size: 14px; color: #15803d;"></div>
                </div>

                <button class="btn btn-secondary btn-sm" onclick="previewReplace()" style="margin-bottom: 16px;">🔍 预览匹配结果</button>

                <div style="background: #dbeafe; padding: 12px; border-radius: 8px; font-size: 13px; color: #1e40af;">
                    💡 系统将自动：
                    <ol style="margin: 8px 0 0 20px; padding: 0;">
                        <li>用正确的文本匹配词库</li>
                        <li>匹配成功则自动入库</li>
                        <li>保存替换规则，下次自动纠正</li>
                    </ol>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('replaceModal')">取消</button>
                <button class="btn btn-primary" onclick="executeReplace()" style="background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);">✓ 确认替换</button>
            </div>
        </div>
    </div>

    <!-- v6.3.2 重新设计：替换弹窗（支持拖动组合短语） -->
    <div class="modal" id="matchModal">
        <div class="modal-content" style="max-width: 600px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
                <h2 style="color: #92400e;">🔄 设置替换规则</h2>
                <button class="modal-close" onclick="closeModal('matchModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="matchItemId">
                <input type="hidden" id="matchItemType">

                <div style="background: #fef3c7; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #92400e; margin-bottom: 4px;">原始文本</div>
                    <div style="font-size: 16px; font-weight: 600; color: #78350f;" id="matchOriginalText"></div>
                </div>

                <!-- 单词池 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #0369a1; margin-bottom: 8px; font-weight: 600;">📦 单词（拖动到下方组合短语）</div>
                    <div id="matchWordPool" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 36px; padding: 10px; background: #f0f9ff; border: 1px solid #bae6fd; border-radius: 8px;">
                    </div>
                </div>

                <!-- 跳过按钮区 -->
                <div style="margin-bottom: 12px;">
                    <button class="btn" onclick="skipAndExclude()" style="width: 100%; padding: 10px 16px; font-size: 14px; font-weight: 600; color: #6b7280; border: 1px dashed #d1d5db; background: #f9fafb;">
                        ⏭️ 跳过（下次不展示、不上报）
                    </button>
                </div>

                <!-- 短语组合区 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #7c3aed; margin-bottom: 8px; font-weight: 600;">🔗 短语组合区（拖入单词或直接输入）</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <div id="matchPhraseBuilder" style="flex: 1; display: flex; flex-wrap: wrap; gap: 6px; min-height: 40px; padding: 10px; background: #faf5ff; border: 2px dashed #c4b5fd; border-radius: 8px; position: relative;"
                             ondrop="dropToBuilder(event)" ondragover="allowDrop(event)" ondragleave="leaveDrop(event)">
                            <input type="text" id="builderInput" placeholder="拖入单词或直接输入..." 
                                   style="flex: 1; min-width: 150px; border: none; background: transparent; outline: none; font-size: 14px; color: #5b21b6;"
                                   onkeydown="if(event.key==='Enter'){buildPhrase(); event.preventDefault();}">
                        </div>
                        <button class="btn btn-sm" onclick="buildPhrase()" style="background: #7c3aed; color: white; padding: 8px 12px; white-space: nowrap;">生成短语</button>
                    </div>
                </div>

                <!-- v6.4 统一搜索区（词库+语法库+替换库） -->
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #0891b2; margin-bottom: 8px; font-weight: 600;">🔍 智能搜索（词库+语法库+替换库）</div>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <input type="text" id="unifiedSearchInput" placeholder="输入关键词，自动搜索全部词库、语法库和替换库..." 
                               style="flex: 1; padding: 10px; border: 1px solid #67e8f9; border-radius: 6px;"
                               onkeydown="if(event.key==='Enter'){searchAllForMatch(); event.preventDefault();}">
                        <button class="btn btn-sm" onclick="searchAllForMatch()" style="background: #0891b2; color: white; padding: 8px 12px; white-space: nowrap;">🔍 搜索</button>
                    </div>
                    <!-- 统一搜索结果 -->
                    <div id="unifiedSearchResults" style="display: none; margin-top: 8px; max-height: 400px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 8px;">
                    </div>
                </div>

                <!-- 已选择的短语和单词 -->
                <div style="margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #059669; margin-bottom: 8px; font-weight: 600;">✅ 已选择（点击移除）</div>
                    <div id="matchSelectedItems" style="display: flex; flex-wrap: wrap; gap: 8px; min-height: 36px; padding: 10px; background: #f0fdf4; border: 1px solid #bbf7d0; border-radius: 8px;">
                        <span style="color: #86efac; font-size: 13px;" id="selectedPlaceholder">点击单词或生成短语添加...</span>
                    </div>
                </div>

                <!-- 需要填写含义的提示 -->
                <div id="matchNeedMeaningTip" style="display: none; background: #fef3c7; padding: 10px 12px; border-radius: 8px; margin-bottom: 16px; font-size: 13px; color: #92400e;">
                    ⚠️ 部分词条词库中未找到，确认后需要填写含义
                </div>

                <div id="matchFilteredWords" style="font-size: 11px; color: #9ca3af; margin-bottom: 12px;"></div>

                <div style="background: #f3f4f6; padding: 10px 12px; border-radius: 8px; font-size: 12px; color: #6b7280;">
                    💡 操作：点击单词直接选中 | 拖动单词到组合区或直接输入文本生成短语 | 使用统一搜索查找词库/语法库/替换库 | 点击已选择项移除
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('matchModal')">取消</button>
                <button class="btn" onclick="executeMatchNew()" style="background: #f59e0b; color: white;">确认替换</button>
            </div>
        </div>
    </div>
    
    <!-- v7.0: 批量填写词条信息弹窗 -->
    <div class="modal" id="batchFillModal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);">
                <h2 style="color: #92400e;">📝 填写词条信息</h2>
                <button class="modal-close" onclick="closeModal('batchFillModal')">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 60vh; overflow-y: auto;">
                <div style="background: #fffbeb; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #92400e; margin-bottom: 4px;">以下词条需要填写信息后才能入库</div>
                    <div style="font-size: 11px; color: #b45309;">填写完成后，词条会自动添加到词库，下次可以直接匹配</div>
                </div>
                
                <div id="batchFillItems">
                    <!-- 动态生成的词条填写表单 -->
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('batchFillModal')">取消</button>
                <button class="btn" onclick="submitBatchFill()" style="background: #f59e0b; color: white;">✓ 确认保存</button>
            </div>
        </div>
    </div>
    
    <!-- v6.0: 转为语法弹窗 -->
    <div class="modal" id="toGrammarModal">
        <div class="modal-content" style="max-width: 650px;">
            <div class="modal-header" style="background: linear-gradient(135deg, #ede9fe 0%, #ddd6fe 100%);">
                <h2 style="color: #6d28d9;">📚 转为语法</h2>
                <button class="modal-close" onclick="closeModal('toGrammarModal')">&times;</button>
            </div>
            <div class="modal-body">
                <input type="hidden" id="grammarItemId">
                <input type="hidden" id="grammarItemType">

                <div style="background: #ede9fe; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #6d28d9; margin-bottom: 4px;">原始文本（被识别为句型）</div>
                    <div style="font-size: 16px; font-weight: 600; color: #5b21b6;" id="grammarOriginalText"></div>
                </div>

                <!-- AI 生成的内容（如果有） -->
                <div id="grammarAiContent" style="display: none; background: #fef3c7; padding: 12px 16px; border-radius: 8px; margin-bottom: 16px;">
                    <div style="font-size: 12px; color: #92400e; margin-bottom: 4px;">🤖 AI 生成内容</div>
                    <div style="font-size: 14px; color: #78350f;" id="grammarAiText"></div>
                </div>

                <!-- 搜索语法库 -->
                <div class="form-group">
                    <label style="color: #6d28d9; font-weight: 600;">搜索语法库</label>
                    <div style="display: flex; gap: 8px;">
                        <input type="text" id="grammarSearchInput" placeholder="输入语法关键词，如：现在完成时、被动语态" style="flex: 1; border-color: #8b5cf6;">
                        <button class="btn btn-sm" onclick="searchGrammarLib()" style="background: #8b5cf6; color: white; padding: 8px 16px;">🔍 搜索</button>
                    </div>
                </div>

                <!-- 搜索结果 -->
                <div id="grammarSearchResults" style="display: none; margin-bottom: 16px;">
                    <div style="font-size: 13px; color: #6d28d9; margin-bottom: 8px; font-weight: 600;">📋 搜索结果（点击选择）</div>
                    <div id="grammarResultsList" style="max-height: 200px; overflow-y: auto; border: 1px solid #e5e5e5; border-radius: 8px 8px 0 0; border-bottom: none;"></div>
                    <!-- 固定在底部的新建按钮 -->
                    <div id="grammarCreateNewBtn" onclick="showNewGrammarForm()" 
                         style="padding: 12px 16px; cursor: pointer; background: #fef3c7; border: 1px solid #e5e5e5; border-radius: 0 0 8px 8px; text-align: center; border-top: 2px dashed #f59e0b;"
                         onmouseover="this.style.background='#fde68a'" onmouseout="this.style.background='#fef3c7'">
                        <div style="color: #92400e; font-weight: 600;">➕ 没找到想要的？点击新建「<span id="grammarCreateNewKeyword"></span>」</div>
                    </div>
                </div>

                <!-- 选中的语法 - v2.0 增强版预览 -->
                <div id="grammarSelected" style="display: none; background: #f0fdf4; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px solid #10b981;">
                    <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                        <div style="flex: 1;">
                            <div style="font-size: 12px; color: #166534; margin-bottom: 4px;">✅ 已选择语法词条</div>
                            <div style="font-size: 16px; font-weight: 600; color: #15803d;" id="grammarSelectedTitle"></div>
                            <div style="font-size: 13px; color: #166534; margin-top: 4px;" id="grammarSelectedDef"></div>
                        </div>
                        <button class="btn btn-sm btn-secondary" onclick="toggleGrammarPreview()" id="previewToggleBtn" style="white-space: nowrap; margin-left: 12px;">📖 展开详情</button>
                    </div>
                    <input type="hidden" id="grammarSelectedId">
                    
                    <!-- v2.0: 目标词条完整预览（可折叠） -->
                    <div id="grammarFullPreview" style="display: none; margin-top: 16px; padding-top: 16px; border-top: 1px dashed #86efac;">
                        <!-- 基本信息 -->
                        <div id="grammarPreviewContent" style="margin-bottom: 12px;">
                            <!-- 动态填充 -->
                        </div>
                        
                        <!-- 已有子话题列表 -->
                        <div id="grammarSubTopicsList" style="margin-top: 12px;">
                            <div style="font-size: 13px; font-weight: 600; color: #166534; margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                <span>📚 已有相关知识点</span>
                                <span style="background: #d1fae5; color: #065f46; padding: 2px 8px; border-radius: 10px; font-size: 11px;" id="subTopicsCount">0</span>
                            </div>
                            <div id="subTopicsContainer" style="max-height: 200px; overflow-y: auto; padding-right: 4px;">
                                <!-- 动态填充 -->
                            </div>
                        </div>
                        
                        <!-- 当前内容预览（将要追加的） -->
                        <div style="margin-top: 16px; background: #fef3c7; padding: 12px; border-radius: 8px; border: 2px dashed #f59e0b;">
                            <div style="font-size: 13px; font-weight: 600; color: #92400e; margin-bottom: 8px;">
                                ➕ 即将追加为新的子话题
                            </div>
                            <div id="pendingSubTopicPreview" style="font-size: 13px; color: #78350f;">
                                <!-- 动态填充 -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 新建语法表单（搜索无结果时显示） - v2.0 增强 -->
                <div id="grammarNewForm" style="display: none; background: #faf5ff; padding: 16px; border-radius: 8px; margin-bottom: 16px; border: 2px dashed #8b5cf6;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <div style="font-size: 13px; color: #6d28d9; font-weight: 600;">⚠️ 语法库中未找到，请填写信息后新建：</div>
                        <button class="btn btn-sm" onclick="quickCreateGrammar()" style="background: #8b5cf6; color: white; font-size: 12px; padding: 4px 10px;">⚡ 快速新建</button>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label style="color: #5b21b6; font-size: 13px;">语法标题 <span style="color:#ef4444">*</span></label>
                        <input type="text" id="grammarNewTitle" placeholder="如：现在完成时、被动语态" style="border-color: #8b5cf6; padding: 8px 10px;">
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label style="color: #5b21b6; font-size: 13px;">分类</label>
                        <select id="grammarNewCategory" style="border-color: #8b5cf6; padding: 8px 10px;">
                            <option value="">选择分类</option>
                            <option value="时态">时态</option>
                            <option value="从句">从句</option>
                            <option value="句式">句式</option>
                            <option value="词法">词法</option>
                            <option value="语态">语态</option>
                            <option value="词汇辨析">词汇辨析</option>
                            <option value="其他">其他</option>
                        </select>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label style="color: #5b21b6; font-size: 13px;">定义说明 <span style="color:#ef4444">*</span></label>
                        <textarea id="grammarNewDefinition" placeholder="语法点的定义说明" style="border-color: #8b5cf6; padding: 8px 10px; min-height: 60px;"></textarea>
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label style="color: #5b21b6; font-size: 13px;">结构</label>
                        <input type="text" id="grammarNewStructure" placeholder="如：have/has + done" style="border-color: #8b5cf6; padding: 8px 10px;">
                    </div>
                    <div class="form-group" style="margin-bottom: 12px;">
                        <label style="color: #5b21b6; font-size: 13px;">关键词（逗号分隔）</label>
                        <input type="text" id="grammarNewKeywords" placeholder="如：现在完成时,have,has,done" style="border-color: #8b5cf6; padding: 8px 10px;">
                    </div>
                    <div class="form-group" style="margin-bottom: 0;">
                        <label style="color: #5b21b6; font-size: 13px;">例句</label>
                        <input type="text" id="grammarNewExample" placeholder="如：She has finished her homework." style="border-color: #8b5cf6; padding: 8px 10px;">
                    </div>
                </div>

                <div style="background: #ede9fe; padding: 12px; border-radius: 8px; font-size: 13px; color: #6d28d9;">
                    💡 系统将：
                    <ol style="margin: 8px 0 0 20px; padding: 0;">
                        <li>如果选择已有语法 → <strong>追加为子话题</strong> + 保存匹配规则</li>
                        <li>如果新建语法 → 保存到语法库 + 保存匹配规则</li>
                        <li>匹配规则：原文 → 语法词条（下次自动匹配）</li>
                    </ol>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal('toGrammarModal')">取消</button>
                <button class="btn" onclick="executeToGrammar()" style="background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%); color: white;">✓ 确认转为语法</button>
            </div>
        </div>
    </div>
    
    <div class="toast" id="toast"></div>
    
    <script>
        const API_BASE = '/api/processing-log';
        const MATCHING_DICT_API = '/api/matching-dict';  // v3.0: 匹配词典API
        
        // 页面加载
        document.addEventListener('DOMContentLoaded', () => {
            loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
            loadTasks();
        });
        
        // 加载统计
        async function loadStats() {
        // 加载精准匹配数量
        fetch('/api/processing-stats')
            .then(res => res.json())
            .then(data => {
                console.log('精准匹配数据:', data);
                const exactBadge = document.getElementById('badgeExactMatches');
                if (exactBadge) {
                    exactBadge.textContent = data.exactMatch || 0;
                    if (data.exactMatch > 0) {
                        exactBadge.style.display = '';
                    }
                    console.log('精准匹配已更新:', data.exactMatch);
                }
            })
            .catch(err => console.error('加载精准匹配失败:', err));
            try {
                const res = await fetch(API_BASE + '/stats');
                const data = await res.json();
                if (data.success) {
                    document.getElementById('statTodayTasks').textContent = data.data.today.tasks;
                    document.getElementById('statPendingMatches').textContent = data.data.pending.pendingMatches;
                    document.getElementById('statPendingUnmatched').textContent = 
                        data.data.pending.pendingUnmatched + data.data.pending.editedUnmatched;
                    document.getElementById('statTodayImported').textContent = data.data.today.imported;
                    
                    // 更新标签页徽章
                    updateBadge('badgePendingMatches', data.data.pending.pendingMatches);
                    updateBadge('badgePendingUnmatched', 
                        data.data.pending.pendingUnmatched + data.data.pending.editedUnmatched);
                }
        // 加载精准匹配统计
        fetch('/api/processing-stats')
            .then(res => res.json())
            .then(data => {
                const exactBadge = document.getElementById('badgeExactMatches');
                if (exactBadge && data.exactMatch) {
                    exactBadge.textContent = data.exactMatch;
                    exactBadge.style.display = '';
                }
            })
            .catch(err => console.error('加载统计失败:', err));
            } catch (e) {
                console.error('加载统计失败:', e);
            }
        }
        
        function updateBadge(id, count) {
            const badge = document.getElementById(id);
            if (count > 0) {
                badge.textContent = count > 99 ? '99+' : count;
                badge.style.display = 'inline-block';
            } else {
                badge.style.display = 'none';
            }
        }
        
        // 切换标签页
        
        // 加载精准匹配列表
        function loadExactMatches() {
            const container = document.getElementById('exactMatchesContainer');
            container.innerHTML = '<div class="loading">加载中...</div>';
            
            fetch('/api/processing-log/exact-matches?limit=50')
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.items && data.items.length > 0) {
                        let html = '<div class="item-list">';
                        data.items.forEach(item => {
                            const matchData = item.matched_data || {};
                            html += `
                                <div class="match-item">
                                    <div class="match-header">
                                        <span class="match-text">${item.original_text}</span>
                                        <span class="match-badge">100%</span>
                                    </div>
                                    <div class="match-body">
                                        <div class="match-result">
                                            <strong>匹配结果：</strong>${item.matched_text || '-'}
                                        </div>
                                        ${matchData.meaning ? `<div class="match-meaning">含义：${matchData.meaning}</div>` : ''}
                                    </div>
                                    <div class="match-footer">
                                        <span class="match-time">${item.created_at || '-'}</span>
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                        container.innerHTML = html;
                    } else {
                        container.innerHTML = '<div class="empty-state"><h3>✅ 没有精准匹配数据</h3></div>';
                    }
                })
                .catch(err => {
                    console.error('加载精准匹配失败:', err);
                    container.innerHTML = '<div class="empty-state"><h3>❌ 加载失败</h3></div>';
                });
        }


        // 加载精准匹配列表
        function loadExactMatches() {
            const container = document.getElementById('exactMatchesContainer');
            container.innerHTML = '<div class="loading">加载中...</div>';
            
            fetch('/api/processing-log/exact-matches?limit=50')
                .then(res => res.json())
                .then(data => {
                    if (data.success && data.items && data.items.length > 0) {
                        let html = '<div class="item-list">';
                        data.items.forEach(item => {
                            const matchData = item.matched_data || {};
                            html += `
                                <div class="match-item">
                                    <div class="match-header">
                                        <span class="match-text">${item.original_text}</span>
                                        <span class="match-badge">100%</span>
                                    </div>
                                    <div class="match-body">
                                        <div class="match-result">
                                            <strong>匹配结果：</strong>${item.matched_text || '-'}
                                        </div>
                                        ${matchData.meaning ? `<div class="match-meaning">含义：${matchData.meaning}</div>` : ''}
                                    </div>
                                    <div class="match-footer">
                                        <span class="match-time">${item.created_at || '-'}</span>
                                    </div>
                                </div>
                            `;
                        });
                        html += '</div>';
                        container.innerHTML = html;
                    } else {
                        container.innerHTML = '<div class="empty-state"><h3>✅ 没有精准匹配数据</h3></div>';
                    }
                })
                .catch(err => {
                    console.error('加载精准匹配失败:', err);
                    container.innerHTML = '<div class="empty-state"><h3>❌ 加载失败</h3></div>';
                });
        }

function switchTab(tab) {
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById('tab-' + tab).classList.add('active');
            
            // 加载对应数据
            if (tab === 'tasks') loadTasks();
            else if (tab === 'pending-matches') loadPendingMatches();
            else if (tab === 'pending-unmatched') loadPendingUnmatched();
        }
        
        // 加载任务列表
        async function loadTasks() {
            const container = document.getElementById('tasksList');
            container.innerHTML = '<div class="loading">加载中...</div>';
            
            try {
                const res = await fetch(API_BASE + '/tasks?limit=50');
                const data = await res.json();
                
                if (!data.success || !data.data.length) {
                    container.innerHTML = '<div class="empty-state"><h3>暂无任务</h3><p>还没有处理过任何任务</p></div>';
                    return;
                }
                
                container.innerHTML = data.data.map(task => `
                    <div class="task-card" onclick="viewTaskDetail('${task.task_id}')">
                        <div class="task-header">
                            <span class="task-id">${task.task_id.substring(0, 8)}...</span>
                            <span class="task-user">${escapeHtml(task.username || '匿名')}</span>
                            <span class="task-time">${formatTime(task.created_at)}</span>
                        </div>
                        <div class="task-file">📄 ${escapeHtml(task.file_name || '未知文件')}</div>
                        <div class="task-stats">
                            <span class="exact">✅ 精确匹配 ${task.exact_match_count || 0}</span>
                            <span class="fuzzy">🟡 模糊匹配 ${task.fuzzy_match_count || 0}</span>
                            <span class="unmatched">❌ 未匹配 ${task.unmatched_count || 0}</span>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                container.innerHTML = '<div class="empty-state"><h3>加载失败</h3></div>';
            }
        }
        
        // 查看任务详情
        async function viewTaskDetail(taskId) {
            const modal = document.getElementById('taskDetailModal');
            const content = document.getElementById('taskDetailContent');
            modal.classList.add('active');
            content.innerHTML = '<div class="loading">加载中...</div>';
            
            try {
                const res = await fetch(API_BASE + '/tasks/' + taskId);
                const data = await res.json();
                
                if (!data.success) {
                    content.innerHTML = '<div class="empty-state"><h3>加载失败</h3></div>';
                    return;
                }
                
                const { task, exactMatches, fuzzyMatches, unmatchedItems, summary } = data.data;
                
                content.innerHTML = `
                    <div class="info-block">
                        <div style="display:flex;gap:20px;flex-wrap:wrap;">
                            <div><span class="info-label">任务ID</span><div class="info-value">${task.task_id}</div></div>
                            <div><span class="info-label">用户</span><div class="info-value">${escapeHtml(task.username)}</div></div>
                            <div><span class="info-label">时间</span><div class="info-value">${formatTime(task.created_at)}</div></div>
                            <div><span class="info-label">文件</span><div class="info-value">${escapeHtml(task.file_name)}</div></div>
                        </div>
                    </div>
                    
                    <div style="display:flex;gap:12px;margin-bottom:20px;flex-wrap:wrap;">
                        <span style="padding:6px 12px;background:#d1fae5;color:#065f46;border-radius:6px;font-size:13px;">
                            ✅ 精确匹配 ${summary.exactMatch}
                        </span>
                        <span style="padding:6px 12px;background:#fef3c7;color:#92400e;border-radius:6px;font-size:13px;">
                            🟡 模糊匹配 ${summary.fuzzyMatch} (待审核 ${summary.pendingReview})
                        </span>
                        <span style="padding:6px 12px;background:#fee2e2;color:#991b1b;border-radius:6px;font-size:13px;">
                            ❌ 未匹配 ${summary.unmatched} (待完善 ${summary.pendingImport})
                        </span>
                    </div>
                    
                    ${fuzzyMatches.length > 0 ? `
                        <h4 style="color:#92400e;margin-bottom:12px;">🟡 模糊匹配 (待审核)</h4>
                        <div style="background:#fffbeb;border-radius:8px;padding:12px;margin-bottom:20px;">
                            ${fuzzyMatches.filter(m => m.status === 'pending').map(m => `
                                <div style="padding:8px 0;border-bottom:1px solid #fef3c7;display:flex;align-items:center;gap:12px;">
                                    <span style="font-weight:500;">${escapeHtml(m.original_text)}</span>
                                    <span style="color:#fbbf24;">→</span>
                                    <span style="color:#059669;">${escapeHtml(m.matched_text)}</span>
                                    <span style="background:#fef3c7;color:#92400e;padding:2px 6px;border-radius:4px;font-size:11px;">
                                        ${(m.match_score * 100).toFixed(0)}%
                                    </span>
                                    <span style="font-size:11px;color:#94a3b8;">${formatTime(m.created_at)}</span>
                                    <span style="flex:1;"></span>
                                    <button class="btn btn-success btn-sm" onclick="confirmMatch(${m.id}, '${escapeJs(m.original_text)}', '${m.item_type}', '${escapeJs(m.matched_text)}', '${m.source_db || 'vocabulary'}', '${m.source_table || ''}', ${m.source_id || 0})">✓ 确认</button>
                                    <button class="btn btn-danger btn-sm" onclick="rejectMatch(${m.id}, '${escapeJs(m.original_text)}', '${m.item_type}', '${escapeJs(m.matched_text)}', ${m.match_score || 0}, '${m.source_db || 'vocabulary'}', '${m.source_table || ''}', ${m.source_id || 0})">✗ 错误</button>
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                    
                    ${unmatchedItems.filter(u => u.status === 'pending' || u.status === 'edited').length > 0 ? `
                        <h4 style="color:#ef4444;margin-bottom:12px;">❌ 未匹配 (待完善)</h4>
                        <div style="background:#fef2f2;border-radius:8px;padding:12px;">
                            ${unmatchedItems.filter(u => u.status === 'pending' || u.status === 'edited').map(u => `
                                <div style="padding:8px 0;border-bottom:1px solid #fee2e2;">
                                    <div style="display:flex;align-items:center;gap:12px;margin-bottom:6px;">
                                        <span style="font-weight:500;">${escapeHtml(u.original_text)}</span>
                                        <span class="item-type">${getTypeLabel(u.item_type)}</span>
                                        <span style="font-size:11px;color:#94a3b8;">${formatTime(u.created_at)}</span>
                                        <span style="flex:1;"></span>
                                        <button class="btn btn-primary btn-sm" onclick="editUnmatched(${u.id})">✎ 编辑</button>
                                        <button class="btn btn-success btn-sm" onclick="importUnmatched(${u.id})">📥 入库</button>
                                    </div>
                                    ${u.ai_generated ? `
                                        <div style="font-size:12px;color:#64748b;background:#fff;padding:8px;border-radius:4px;">
                                            <span style="color:#f59e0b;font-weight:500;">AI生成:</span>
                                            ${formatAIContent(u.ai_generated)}
                                        </div>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    ` : ''}
                `;
            } catch (e) {
                content.innerHTML = '<div class="empty-state"><h3>加载失败</h3></div>';
            }
        }
        
        // 加载待审核匹配
        async function loadPendingMatches() {
            const container = document.getElementById('pendingMatchesList');
            container.innerHTML = '<div class="loading">加载中...</div>';
            
            try {
                const res = await fetch(API_BASE + '/pending-matches');
                const data = await res.json();
                
                if (!data.success || !data.data.length) {
                    container.innerHTML = '<div class="empty-state"><h3>🎉 太棒了！</h3><p>没有待审核的模糊匹配</p></div>';
                    return;
                }
                
                container.innerHTML = data.data.map(m => {
                    // v4.4.0: 检查是否匹配到子话题
                    const hasSubtopic = m.matched_subtopic_title && m.matched_data;
                    
                    // 基础信息行
                    let html = `
                    <div class="match-item ${hasSubtopic ? 'has-subtopic' : ''}">
                        <div class="item-icon fuzzy">🟡</div>
                        <div class="item-content">
                            <div class="item-original">${escapeHtml(m.original_text)}</div>
                            <div class="item-matched">
                                <span class="arrow">→</span>
                                <span class="matched-text">${escapeHtml(m.matched_text)}</span>
                                ${hasSubtopic ? `<span class="subtopic-arrow">&gt;</span><span class="subtopic-highlight">${escapeHtml(m.matched_subtopic_title)}</span>` : ''}
                                <span class="score">${(m.match_score * 100).toFixed(0)}%</span>
                                <span class="item-type">${getTypeLabel(m.item_type)}</span>
                            </div>`;
                    
                    // v4.4.0: 如果匹配到子话题，展示完整知识体系
                    if (hasSubtopic) {
                        const mainData = m.matched_data;
                        let subTopics = [];
                        try {
                            subTopics = typeof mainData.sub_topics === 'string' 
                                ? JSON.parse(mainData.sub_topics) 
                                : (mainData.sub_topics || []);
                        } catch (e) {
                            subTopics = [];
                        }
                        
                        html += `
                            <div class="knowledge-system">
                                <div class="main-topic-section">
                                    <div class="section-title">【主话题】${escapeHtml(m.matched_text)}</div>
                                    ${mainData.definition ? `<div class="field"><label>定义:</label>${escapeHtml(mainData.definition)}</div>` : ''}
                                    ${mainData.structure ? `<div class="field"><label>结构:</label><code>${escapeHtml(mainData.structure)}</code></div>` : ''}
                                    ${mainData.usage ? `<div class="field"><label>用法:</label>${formatArrayField(mainData.usage)}</div>` : ''}
                                    ${mainData.examples ? `<div class="field"><label>例句:</label>${formatArrayField(mainData.examples)}</div>` : ''}
                                </div>
                                
                                ${subTopics.length > 0 ? `
                                <div class="subtopics-section">
                                    <div class="section-title">【子话题列表】</div>
                                    ${subTopics.map((st, idx) => {
                                        const isHit = idx === m.matched_subtopic_index;
                                        return `
                                        <div class="subtopic-item ${isHit ? 'hit' : ''}">
                                            <div class="subtopic-header">
                                                <span class="subtopic-icon">${isHit ? '🔴' : '⚪'}</span>
                                                <span class="subtopic-name">${escapeHtml(st.title)}</span>
                                                ${isHit ? '<span class="hit-badge">击中</span>' : ''}
                                            </div>
                                            ${st.definition ? `<div class="subtopic-field"><label>定义:</label>${escapeHtml(st.definition)}</div>` : ''}
                                            ${st.structure ? `<div class="subtopic-field"><label>结构:</label><code>${escapeHtml(st.structure)}</code></div>` : ''}
                                            ${st.examples && st.examples.length > 0 ? `<div class="subtopic-field"><label>例句:</label>${formatArrayField(st.examples)}</div>` : ''}
                                        </div>
                                        `;
                                    }).join('')}
                                </div>
                                ` : ''}
                            </div>`;
                    }
                    
                    html += `
                            <div style="font-size:12px;color:#94a3b8;margin-top:6px;">
                                来自: ${escapeHtml(m.username || '匿名')} · ${escapeHtml(m.file_name || '')} · <span style="color:#f59e0b;">${formatTime(m.created_at)}</span>
                            </div>
                        </div>
                        <div class="item-actions">
                            <button class="btn btn-success btn-sm" onclick="confirmMatch(${m.id}, '${escapeJs(m.original_text)}', '${m.item_type}', '${escapeJs(m.matched_text)}', '${m.source_db || 'vocabulary'}', '${m.source_table || ''}', ${m.source_id || 0})">✓ 确认正确</button>
                            <button class="btn btn-primary btn-sm" onclick="editMatch(${m.id})">✎ 编辑</button>
                            <button class="btn btn-secondary btn-sm" onclick="excludeMatch(${m.id}, '${escapeJs(m.original_text)}', '${escapeJs(m.matched_text)}')">🗑 排除</button>
                        </div>
                    </div>
                    `;
                    
                    return html;
                }).join('');
            } catch (e) {
                console.error('[loadPendingMatches] 渲染失败:', e);
                container.innerHTML = '<div class="empty-state"><h3>加载失败</h3></div>';
            }
        }
        
        // v4.4.0 新增：格式化数组字段
        function formatArrayField(arr) {
            if (!arr || !Array.isArray(arr) || arr.length === 0) return '';
            if (typeof arr[0] === 'string') {
                return arr.map(item => `<span class="array-item">${escapeHtml(item)}</span>`).join('');
            }
            return escapeHtml(JSON.stringify(arr));
        }
        
        // 加载待完善入库
        async function loadPendingUnmatched() {
            const container = document.getElementById('pendingUnmatchedList');
            container.innerHTML = '<div class="loading">加载中...</div>';
            
            try {
                const res = await fetch(API_BASE + '/pending-unmatched');
                const data = await res.json();
                
                if (!data.success || !data.data.length) {
                    container.innerHTML = '<div class="empty-state"><h3>🎉 太棒了！</h3><p>没有待完善的数据</p></div>';
                    return;
                }
                
                container.innerHTML = data.data.map(u => `
                    <div class="match-item">
                        <div class="item-icon unmatched">❌</div>
                        <div class="item-content">
                            <div class="item-original">${escapeHtml(u.original_text)}</div>
                            <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
                                <span class="item-type">${getTypeLabel(u.item_type)}</span>
                                <span class="status-badge ${u.status}">${getStatusLabel(u.status)}</span>
                            </div>
                            ${u.ai_generated ? `
                                <div class="item-ai-content">
                                    <div class="ai-label">AI 生成内容</div>
                                    ${formatAIContent(u.ai_generated)}
                                </div>
                            ` : ''}
                            <div style="font-size:12px;color:#94a3b8;margin-top:6px;">
                                来自: ${escapeHtml(u.username || '匿名')} · ${escapeHtml(u.file_name || '')} · <span style="color:#f59e0b;">${formatTime(u.created_at)}</span>
                            </div>
                        </div>
                        <div class="item-actions">
                            <button class="btn btn-primary btn-sm" onclick="editUnmatched(${u.id})">✎ 编辑</button>
                            <button class="btn btn-success btn-sm" onclick="importUnmatched(${u.id})">📥 完善入库</button>
                            <button class="btn btn-secondary btn-sm" onclick="ignoreUnmatched(${u.id})">🗑 忽略</button>
                        </div>
                    </div>
                `).join('');
            } catch (e) {
                container.innerHTML = '<div class="empty-state"><h3>加载失败</h3></div>';
            }
        }
        
        // 确认匹配
        // v3.0: 同时保存到匹配词典
        async function confirmMatch(id, originalText, originalType, matchedText, sourceDb, sourceTable, sourceId) {
            try {
                // 1. 确认匹配
                const res = await fetch(API_BASE + '/matches/' + id + '/confirm', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reviewedBy: 'admin' })
                });
                const data = await res.json();
                
                if (data.success) {
                    // 2. v3.0: 保存到匹配词典
                    try {
                        await fetch(MATCHING_DICT_API + '/confirm-match', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                original_text: originalText,
                                original_type: originalType,
                                target_db: sourceDb ? sourceDb + '.db' : 'vocabulary.db',
                                target_table: sourceTable,
                                target_id: sourceId,
                                target_text: matchedText,
                                created_by: 'admin'
                            })
                        });
                        console.log('[匹配词典] 已保存:', originalText, '→', matchedText);
                    } catch (dictErr) {
                        console.error('[匹配词典] 保存失败:', dictErr);
                    }
                    
                    showToast('已确认并记录到匹配词典', 'success');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadPendingMatches();
                } else {
                    showToast(data.error || '操作失败', 'error');
                }
            } catch (e) {
                showToast('操作失败', 'error');
            }
        }
        
        // 标记匹配错误
        // v3.0: 显示选择弹窗
        function rejectMatch(id, originalText, originalType, matchedText, score, sourceDb, sourceTable, sourceId) {
            // 填充弹窗数据
            document.getElementById('rejectMatchId').value = id;
            document.getElementById('rejectOriginalText').value = originalText;
            document.getElementById('rejectOriginalType').value = originalType;
            document.getElementById('rejectMatchedText').value = matchedText;
            document.getElementById('rejectSourceDb').value = sourceDb || '';
            document.getElementById('rejectSourceTable').value = sourceTable || '';
            document.getElementById('rejectSourceId').value = sourceId || '';
            
            // 显示信息
            document.getElementById('rejectDisplayOriginal').textContent = originalText;
            document.getElementById('rejectDisplayMatched').textContent = matchedText;
            document.getElementById('rejectDisplayScore').textContent = score ? `(${Math.round(score * 100)}%)` : '';
            
            // 更新"不是XX"的标签
            const typeLabels = {
                'word': '不是单词（识别错误）',
                'phrase': '不是短语（识别错误）',
                'pattern': '不是句型（识别错误）',
                'grammar': '不是语法（识别错误）'
            };
            document.getElementById('rejectExcludeLabel').textContent = typeLabels[originalType] || '不是该类型（识别错误）';
            
            // 重置选项
            document.querySelector('input[name="rejectAction"][value="wrong"]').checked = true;
            document.getElementById('correctMatchSection').style.display = 'block';
            
            // v5.5 新增：重置新建词条区域
            document.getElementById('newEntrySection').style.display = 'none';
            document.getElementById('newEntryText').value = originalText;  // 预填原文
            document.getElementById('newEntryMeaning').value = '';
            document.getElementById('newEntryExample').value = '';
            
            // 加载词库选项
            loadVocabularyOptions(originalType);
            
            // 显示弹窗
            document.getElementById('rejectModal').classList.add('active');
            
            // 监听选项变化
            document.querySelectorAll('input[name="rejectAction"]').forEach(radio => {
                radio.onchange = function() {
                    // v5.5 修改：根据选项显示不同区域
                    document.getElementById('correctMatchSection').style.display = 
                        this.value === 'wrong' ? 'block' : 'none';
                    document.getElementById('newEntrySection').style.display = 
                        this.value === 'new' ? 'block' : 'none';
                };
            });
        }
        
        // v4.5.0 新增：编辑模糊匹配
        async function editMatch(id) {
            try {
                // 1. 加载模糊匹配记录
                const res = await fetch(API_BASE + '/matches/' + id);
                const data = await res.json();
                
                if (!data.success) {
                    showToast('加载失败', 'error');
                    return;
                }
                
                const match = data.data;
                
                // 2. 获取匹配到的完整数据
                let matchedData = match.matched_data;
                if (typeof matchedData === 'string') {
                    try {
                        matchedData = JSON.parse(matchedData);
                    } catch (e) {
                        console.error('解析matched_data失败:', e);
                        matchedData = {};
                    }
                }
                
                // 3. 标记当前正在编辑模糊匹配（用于saveAndImport判断）
                window._editingMatchId = id;
                window._editingMatchData = {
                    original_text: match.original_text,
                    original_type: match.item_type,
                    matched_text: match.matched_text,
                    source_db: match.source_db,
                    source_table: match.source_table,
                    source_id: match.source_id
                };
                
                // 4. 填充编辑弹窗
                document.getElementById('editItemId').value = '';  // 清空，表示这是模糊匹配编辑
                document.getElementById('editItemType').value = match.item_type;
                document.getElementById('editOriginalText').textContent = match.original_text;
                document.getElementById('editTargetType').value = match.item_type;
                document.getElementById('editCategory').value = matchedData.category || '';
                
                // 5. 根据类型显示不同字段
                if (match.item_type === 'grammar') {
                    document.getElementById('vocabFields').style.display = 'none';
                    document.getElementById('grammarFields').style.display = 'block';
                    document.getElementById('editDefinition').value = matchedData.definition || '';
                    document.getElementById('editStructure').value = matchedData.structure || '';
                    document.getElementById('editUsage').value = Array.isArray(matchedData.usage) 
                        ? matchedData.usage.join('\n') 
                        : (matchedData.usage || '');
                    document.getElementById('editExamples').value = Array.isArray(matchedData.examples) 
                        ? matchedData.examples.join('\n') 
                        : (matchedData.examples || '');
                    document.getElementById('editMistakes').value = Array.isArray(matchedData.mistakes) 
                        ? matchedData.mistakes.join('\n') 
                        : (matchedData.mistakes || '');
                } else {
                    document.getElementById('vocabFields').style.display = 'block';
                    document.getElementById('grammarFields').style.display = 'none';
                    document.getElementById('editPhonetic').value = matchedData.phonetic || '';
                    
                    // 自动格式化词性和含义
                    const formatted = formatPosAndMeaning(matchedData.pos, matchedData.meaning);
                    document.getElementById('editPos').value = formatted.pos;
                    document.getElementById('editMeaning').value = formatted.meaning;
                    
                    document.getElementById('editExample').value = matchedData.example || '';
                }
                
                // 6. 修改弹窗标题
                document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑匹配项';
                
                // 7. 显示提示信息
                const infoDiv = document.createElement('div');
                infoDiv.className = 'info-block';
                infoDiv.id = 'matchEditInfo';
                infoDiv.innerHTML = `
                    <div style="font-size:12px;color:#92400e;">
                        <strong>📝 编辑说明：</strong><br>
                        匹配到：${escapeHtml(match.matched_text)} (${(match.match_score * 100).toFixed(0)}%)<br>
                        保存后将更新原记录，完善词库内容
                    </div>
                `;
                
                // 插入到弹窗顶部
                const modalBody = document.querySelector('#editModal .modal-body');
                const existingInfo = document.getElementById('matchEditInfo');
                if (existingInfo) {
                    existingInfo.remove();
                }
                modalBody.insertBefore(infoDiv, modalBody.firstChild);
                
                // 8. 打开弹窗
                document.getElementById('editModal').classList.add('active');
                
            } catch (e) {
                console.error('[editMatch] 失败:', e);
                showToast('加载失败', 'error');
            }
        }
        
        // v4.5.0 新增：排除误匹配
        // v4.5.0 新增：排除误匹配
        // v4.5.1 更新：排除 = 替换成空值 = 跳过不处理
        async function excludeMatch(id, originalText, matchedText) {
            if (!confirm(`确定排除此匹配？\n\n原文：${originalText}\n匹配到：${matchedText}\n\n排除后：\n• 保存到替换库（替换为空值）\n• 下次遇到相同内容将跳过不处理`)) {
                return;
            }
            
            try {
                const res = await fetch(API_BASE + '/matches/' + id + '/exclude', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        reason: '用户手动排除（误匹配）'
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showToast('已加入替换库（排除）', 'success');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadPendingMatches();
                } else {
                    showToast(data.error || '操作失败', 'error');
                }
            } catch (e) {
                console.error('[excludeMatch] 失败:', e);
                showToast('操作失败', 'error');
            }
        }
        
        // v7.0: 当前搜索类型（用于搜索时知道要搜哪个库）
        let currentSearchType = 'phrase';
        let searchTimeout = null;
        
        // 加载词库选项（初始化时调用，设置搜索类型）
        async function loadVocabularyOptions(type) {
            currentSearchType = type;
            // 清空搜索框和结果
            document.getElementById('correctMatchSearch').value = '';
            document.getElementById('correctMatchSelect').value = '';
            document.getElementById('searchResultsContainer').style.display = 'none';
            document.getElementById('searchResultsContainer').innerHTML = '';
            document.getElementById('selectedMatch').style.display = 'none';
            
            // 设置搜索框占位符
            const typeLabel = {word: '单词', phrase: '短语', pattern: '句型', grammar: '语法'}[type] || type;
            document.getElementById('correctMatchSearch').placeholder = `🔍 输入关键词搜索${typeLabel}库...`;
        }
        
        // v7.0: 搜索词库
        async function searchVocabulary(keyword) {
            // 防抖
            if (searchTimeout) clearTimeout(searchTimeout);
            
            const container = document.getElementById('searchResultsContainer');
            const loading = document.getElementById('searchLoading');
            
            if (!keyword || keyword.trim().length < 1) {
                container.style.display = 'none';
                return;
            }
            
            searchTimeout = setTimeout(async () => {
                loading.style.display = 'block';
                
                try {
                    let url = '';
                    if (currentSearchType === 'grammar') {
                        url = `/api/grammar?search=${encodeURIComponent(keyword)}&limit=50`;
                    } else {
                        url = `/api/vocabulary/${currentSearchType}s?search=${encodeURIComponent(keyword)}&limit=50`;
                    }
                    
                    const res = await fetch(url);
                    const data = await res.json();
                    
                    loading.style.display = 'none';
                    
                    if (data.success && data.data && data.data.length > 0) {
                        container.innerHTML = data.data.map(item => {
                            const text = item.word || item.phrase || item.pattern || item.title;
                            const meaning = item.meaning || item.definition || '';
                            const db = currentSearchType === 'grammar' ? 'grammar' : 'vocabulary';
                            const table = currentSearchType === 'grammar' ? 'grammar' : (currentSearchType + 's');
                            const value = `${item.id}|${db}|${table}|${text}`;
                            
                            return `
                                <div class="search-result-item" onclick="selectVocabularyItem('${value.replace(/'/g, "\\'")}', '${text.replace(/'/g, "\\'")}')" 
                                    style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e7eb; transition: background 0.2s;"
                                    onmouseover="this.style.background='#dcfce7'" onmouseout="this.style.background='white'">
                                    <div style="font-weight: 500; color: #15803d;">${escapeHtml(text)}</div>
                                    ${meaning ? `<div style="font-size: 12px; color: #6b7280; margin-top: 2px;">${escapeHtml(meaning)}</div>` : ''}
                                </div>
                            `;
                        }).join('');
                        container.style.display = 'block';
                    } else {
                        container.innerHTML = '<div style="padding: 12px; color: #6b7280; text-align: center;">没有找到匹配的词条</div>';
                        container.style.display = 'block';
                    }
                } catch (e) {
                    loading.style.display = 'none';
                    container.innerHTML = '<div style="padding: 12px; color: #dc2626; text-align: center;">搜索失败，请重试</div>';
                    container.style.display = 'block';
                }
            }, 300);  // 300ms 防抖
        }
        
        // v7.0: 选择词条
        function selectVocabularyItem(value, text) {
            document.getElementById('correctMatchSelect').value = value;
            document.getElementById('selectedMatchText').textContent = text;
            document.getElementById('selectedMatch').style.display = 'block';
            document.getElementById('searchResultsContainer').style.display = 'none';
            document.getElementById('correctMatchSearch').value = '';
        }
        
        // v7.0: 清除选择
        window.clearSelectedMatch = function clearSelectedMatch() {
            document.getElementById('correctMatchSelect').value = '';
            document.getElementById('selectedMatch').style.display = 'none';
        }
        
        // 执行标记错误操作
        async function executeReject() {
            const action = document.querySelector('input[name="rejectAction"]:checked').value;
            const matchId = document.getElementById('rejectMatchId').value;
            const originalText = document.getElementById('rejectOriginalText').value;
            const originalType = document.getElementById('rejectOriginalType').value;
            
            try {
                if (action === 'exclude') {
                    // v6.1 修复：改为打开 excludeModal 弹窗，复用现有功能
                    closeModal('rejectModal');
                    openExcludeModalFromReject(matchId, originalText, originalType);
                    return;  // 不继续执行，等 excludeModal 处理完
                } else if (action === 'wrong') {
                    // 选择正确的词条
                    const selected = document.getElementById('correctMatchSelect').value;
                    if (!selected) {
                        showToast('请选择正确的词条', 'error');
                        return;
                    }
                    
                    const [targetId, targetDb, targetTable, targetText] = selected.split('|');
                    
                    // 添加到匹配词典
                    const res = await fetch(MATCHING_DICT_API + '/confirm-match', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            original_text: originalText,
                            original_type: originalType,
                            target_db: targetDb + '.db',
                            target_table: targetTable,
                            target_id: parseInt(targetId),
                            target_text: targetText,
                            created_by: 'admin'
                        })
                    });
                    const data = await res.json();
                    
                    if (data.success) {
                        // 标记原匹配为错误
                        await fetch(API_BASE + '/matches/' + matchId + '/reject', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ reviewedBy: 'admin', notes: '已修正为: ' + targetText })
                        });
                        
                        showToast('已修正并记录到匹配词典', 'success');
                    } else {
                        showToast(data.error || '操作失败', 'error');
                        return;
                    }
                } else if (action === 'new') {
                    // v5.5 重写：新建词条并保存匹配关系
                    const newText = document.getElementById('newEntryText').value.trim();
                    const newMeaning = document.getElementById('newEntryMeaning').value.trim();
                    const newExample = document.getElementById('newEntryExample').value.trim();
                    
                    if (!newText) {
                        showToast('请输入词条内容', 'error');
                        return;
                    }
                    if (!newMeaning) {
                        showToast('请输入中文含义', 'error');
                        return;
                    }
                    
                    // 根据类型确定API和数据格式
                    let apiUrl = '';
                    let postData = {};
                    let targetTable = '';
                    let targetDb = '';
                    
                    if (originalType === 'grammar') {
                        apiUrl = '/api/grammar';
                        postData = {
                            title: newText,
                            keywords: [newText],
                            definition: newMeaning,
                            structure: '',
                            usage: [],
                            examples: newExample ? [newExample] : [],
                            mistakes: [],
                            category: '其他'
                        };
                        targetTable = 'grammar';
                        targetDb = 'grammar';
                    } else if (originalType === 'phrase') {
                        apiUrl = '/api/vocabulary/phrases';
                        postData = {
                            phrase: newText,
                            meaning: newMeaning,
                            example: newExample,
                            category: '其他'
                        };
                        targetTable = 'phrases';
                        targetDb = 'vocabulary';
                    } else if (originalType === 'pattern') {
                        apiUrl = '/api/vocabulary/patterns';
                        postData = {
                            pattern: newText,
                            meaning: newMeaning,
                            example: newExample,
                            category: '其他'
                        };
                        targetTable = 'patterns';
                        targetDb = 'vocabulary';
                    } else {
                        // 默认当作单词
                        apiUrl = '/api/vocabulary/words';
                        postData = {
                            word: newText,
                            phonetic: '',
                            pos: '',
                            meaning: newMeaning,
                            example: newExample,
                            category: '其他'
                        };
                        targetTable = 'words';
                        targetDb = 'vocabulary';
                    }
                    
                    // 1. 创建新词条
                    const createRes = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(postData)
                    });
                    const createData = await createRes.json();
                    
                    if (!createData.success) {
                        showToast(createData.error || '创建词条失败', 'error');
                        return;
                    }
                    
                    const newId = createData.id;
                    console.log(`[新建词条] 创建成功: ${newText} (ID: ${newId})`);
                    
                    // 2. 保存到匹配词典
                    const dictRes = await fetch(MATCHING_DICT_API + '/confirm-match', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            original_text: originalText,
                            original_type: originalType,
                            target_db: targetDb + '.db',
                            target_table: targetTable,
                            target_id: newId,
                            target_text: newText,
                            created_by: 'admin'
                        })
                    });
                    const dictData = await dictRes.json();
                    
                    if (!dictData.success) {
                        console.warn('[匹配词典] 保存失败:', dictData.error);
                        // 词条已创建，即使词典保存失败也继续
                    } else {
                        console.log('[匹配词典] 已保存:', originalText, '→', newText);
                    }
                    
                    // 3. 标记原匹配为错误
                    await fetch(API_BASE + '/matches/' + matchId + '/reject', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            reviewedBy: 'admin', 
                            notes: '已新建词条: ' + newText 
                        })
                    });
                    
                    showToast(`新建成功！"${newText}" 已添加到${getTypeLabel(originalType)}库`, 'success');
                }
                
                closeModal('rejectModal');
                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                loadPendingMatches();
            } catch (e) {
                console.error('操作失败:', e);
                showToast('操作失败', 'error');
            }
        }
        
        // 批量确认所有匹配
        async function confirmAllMatches() {
            if (!confirm('确定将所有待审核的模糊匹配标记为正确？')) return;
            
            try {
                const res = await fetch(API_BASE + '/pending-matches');
                const data = await res.json();
                if (data.success && data.data.length > 0) {
                    for (const item of data.data) {
                        await fetch(API_BASE + '/matches/' + item.id + '/confirm', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ reviewedBy: 'admin' })
                        });
                    }
                    showToast(`已确认 ${data.data.length} 条记录`, 'success');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadPendingMatches();
                } else {
                    showToast('没有待确认的记录', 'success');
                }
            } catch (e) {
                showToast('操作失败', 'error');
            }
        }
        
        /**
         * v5.5 新增：格式化词性和含义
         * 将 "n./v." + "工作 / 工作" 格式化为 "n.工作；v.工作"
         */
        function formatPosAndMeaning(pos, meaning) {
            if (!pos || !meaning) {
                return { pos: pos || '', meaning: meaning || '' };
            }
            
            // 如果词性不包含分隔符，直接返回原始值
            if (!pos.includes('/') && !pos.includes('、') && !pos.includes(',')) {
                return { pos, meaning };
            }
            
            // 分割词性（支持 / 、 , 分隔符）
            const posList = pos.split(/[\/、,]/).map(p => p.trim()).filter(p => p);
            
            // 分割含义（支持 / 、 ; 分隔符，但要避免拆分中文分号内的内容）
            // 优先用 / 分割，因为AI通常用 / 分隔不同词性的含义
            let meaningList = meaning.split(/\s*\/\s*/).map(m => m.trim()).filter(m => m);
            
            // 如果 / 分割后数量不匹配，尝试用其他方式
            if (meaningList.length !== posList.length) {
                // 可能整个含义是一体的，不需要分割
                meaningList = [meaning];
            }
            
            // 如果词性和含义数量匹配，配对合并
            if (posList.length > 1 && meaningList.length === posList.length) {
                let combined = [];
                for (let i = 0; i < posList.length; i++) {
                    // 确保词性以 . 结尾
                    let p = posList[i];
                    if (!p.endsWith('.')) p += '.';
                    combined.push(`${p}${meaningList[i]}`);
                }
                return { pos: '', meaning: combined.join('；') };
            }
            
            // 如果只有一个含义但多个词性，把所有词性放前面
            if (posList.length > 1 && meaningList.length === 1) {
                let posStr = posList.map(p => p.endsWith('.') ? p : p + '.').join('/');
                return { pos: posStr, meaning: meaning };
            }
            
            // 其他情况返回原始值
            return { pos, meaning };
        }
        
        // 编辑未匹配项
        async function editUnmatched(id) {
            try {
                // 清除模糊匹配的编辑提示（如果存在）
                const existingInfo = document.getElementById('matchEditInfo');
                if (existingInfo) {
                    existingInfo.remove();
                }
                
                const res = await fetch(API_BASE + '/unmatched/' + id);
                const data = await res.json();
                if (!data.success) {
                    showToast('加载失败', 'error');
                    return;
                }
                
                const item = data.data;
                const content = item.edited_content || item.ai_generated || {};
                
                document.getElementById('editItemId').value = id;
                document.getElementById('editItemType').value = item.item_type;
                document.getElementById('editOriginalText').textContent = item.original_text;
                document.getElementById('editTargetType').value = item.item_type;
                document.getElementById('editCategory').value = content.category || '';
                
                // 根据类型显示不同字段
                if (item.item_type === 'grammar') {
                    document.getElementById('vocabFields').style.display = 'none';
                    document.getElementById('grammarFields').style.display = 'block';
                    document.getElementById('editDefinition').value = content.definition || '';
                    document.getElementById('editStructure').value = content.structure || '';
                    document.getElementById('editUsage').value = Array.isArray(content.usage) ? content.usage.join('\n') : (content.usage || '');
                    document.getElementById('editExamples').value = Array.isArray(content.examples) ? content.examples.join('\n') : (content.examples || '');
                    document.getElementById('editMistakes').value = Array.isArray(content.mistakes) ? content.mistakes.join('\n') : (content.mistakes || '');
                } else {
                    document.getElementById('vocabFields').style.display = 'block';
                    document.getElementById('grammarFields').style.display = 'none';
                    document.getElementById('editPhonetic').value = content.phonetic || '';
                    
                    // v5.5: 自动格式化词性和含义
                    const formatted = formatPosAndMeaning(content.pos, content.meaning);
                    document.getElementById('editPos').value = formatted.pos;
                    document.getElementById('editMeaning').value = formatted.meaning;
                    
                    document.getElementById('editExample').value = content.example || '';
                }
                
                document.getElementById('editModal').classList.add('active');
                
                // v6.2: 排除按钮统一为"排除"
                // v7.0: excludeBtn 已删除
            } catch (e) {
                showToast('加载失败', 'error');
            }
        }
        
        // 保存编辑
        async function saveEdit() {
            const id = document.getElementById('editItemId').value;
            const itemType = document.getElementById('editItemType').value;
            const targetType = document.getElementById('editTargetType').value;
            
            let editedContent = {
                category: document.getElementById('editCategory').value
            };
            
            if (targetType === 'grammar') {
                editedContent.definition = document.getElementById('editDefinition').value;
                editedContent.structure = document.getElementById('editStructure').value;
                editedContent.usage = document.getElementById('editUsage').value.split('\n').filter(s => s.trim());
                editedContent.examples = document.getElementById('editExamples').value.split('\n').filter(s => s.trim());
                editedContent.mistakes = document.getElementById('editMistakes').value.split('\n').filter(s => s.trim());
            } else {
                editedContent.phonetic = document.getElementById('editPhonetic').value;
                editedContent.pos = document.getElementById('editPos').value;
                editedContent.meaning = document.getElementById('editMeaning').value;
                editedContent.example = document.getElementById('editExample').value;
            }
            
            // v5.5: 新建模式（从排除弹窗触发）
            if (!id) {
                // 新建模式，不需要保存到unmatched，返回编辑内容供入库使用
                return editedContent;
            }
            
            try {
                const res = await fetch(API_BASE + '/unmatched/' + id, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ editedContent })
                });
                const data = await res.json();
                if (data.success) {
                    showToast('保存成功', 'success');
                    loadPendingUnmatched();
                } else {
                    showToast(data.error || '保存失败', 'error');
                }
            } catch (e) {
                showToast('保存失败', 'error');
            }
            
            return editedContent;
        }
        
        // 保存并入库
        async function saveAndImport() {
            const id = document.getElementById('editItemId').value;
            const targetType = document.getElementById('editTargetType').value;
            const originalText = document.getElementById('editOriginalText').textContent;
            
            // v4.5.0: 处理模糊匹配的编辑保存
            if (window._editingMatchId) {
                const matchId = window._editingMatchId;
                const matchData = window._editingMatchData;
                
                // 收集编辑后的内容
                let editedContent = {
                    category: document.getElementById('editCategory').value
                };
                
                if (targetType === 'grammar') {
                    editedContent.definition = document.getElementById('editDefinition').value;
                    editedContent.structure = document.getElementById('editStructure').value;
                    editedContent.usage = document.getElementById('editUsage').value.split('\n').filter(s => s.trim());
                    editedContent.examples = document.getElementById('editExamples').value.split('\n').filter(s => s.trim());
                    editedContent.mistakes = document.getElementById('editMistakes').value.split('\n').filter(s => s.trim());
                } else {
                    editedContent.phonetic = document.getElementById('editPhonetic').value;
                    editedContent.pos = document.getElementById('editPos').value;
                    editedContent.meaning = document.getElementById('editMeaning').value;
                    editedContent.example = document.getElementById('editExample').value;
                }
                
                try {
                    // 1. 更新原记录（方案A：更新原匹配到的位置）
                    let updateApiUrl = '';
                    let updateData = {};
                    
                    if (matchData.source_db === 'grammar' || targetType === 'grammar') {
                        updateApiUrl = `/api/grammar/${matchData.source_id}`;
                        updateData = {
                            title: matchData.matched_text,
                            definition: editedContent.definition,
                            structure: editedContent.structure,
                            usage: editedContent.usage,
                            examples: editedContent.examples,
                            mistakes: editedContent.mistakes,
                            category: editedContent.category
                        };
                    } else {
                        // 词库更新
                        const table = matchData.source_table || 'words';
                        if (table === 'words') {
                            updateApiUrl = `/api/vocabulary/words/${matchData.source_id}`;
                            updateData = {
                                word: matchData.matched_text,
                                phonetic: editedContent.phonetic,
                                pos: editedContent.pos,
                                meaning: editedContent.meaning,
                                example: editedContent.example,
                                category: editedContent.category
                            };
                        } else if (table === 'phrases') {
                            updateApiUrl = `/api/vocabulary/phrases/${matchData.source_id}`;
                            updateData = {
                                phrase: matchData.matched_text,
                                meaning: editedContent.meaning,
                                example: editedContent.example,
                                category: editedContent.category
                            };
                        } else if (table === 'patterns') {
                            updateApiUrl = `/api/vocabulary/patterns/${matchData.source_id}`;
                            updateData = {
                                pattern: matchData.matched_text,
                                meaning: editedContent.meaning,
                                example: editedContent.example,
                                category: editedContent.category
                            };
                        }
                    }
                    
                    const updateRes = await fetch(updateApiUrl, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(updateData)
                    });
                    
                    const updateResult = await updateRes.json();
                    
                    if (updateResult.success) {
                        // 2. 确认匹配并保存到匹配词典
                        await fetch(API_BASE + '/matches/' + matchId + '/confirm', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ reviewedBy: 'admin' })
                        });
                        
                        await fetch(MATCHING_DICT_API + '/confirm-match', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                original_text: matchData.original_text,
                                original_type: matchData.original_type,
                                target_db: matchData.source_db ? matchData.source_db + '.db' : 'vocabulary.db',
                                target_table: matchData.source_table,
                                target_id: matchData.source_id,
                                target_text: matchData.matched_text,
                                created_by: 'admin'
                            })
                        });
                        
                        showToast('已更新词库并确认匹配', 'success');
                        
                        // 清理状态
                        window._editingMatchId = null;
                        window._editingMatchData = null;
                        
                        // 移除提示信息
                        const matchEditInfo = document.getElementById('matchEditInfo');
                        if (matchEditInfo) {
                            matchEditInfo.remove();
                        }
                        
                        // 恢复弹窗标题
                        document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                        
                        closeModal('editModal', true);
                        loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                        loadPendingMatches();
                    } else {
                        showToast(updateResult.error || '更新失败', 'error');
                    }
                } catch (e) {
                    console.error('[saveAndImport] 模糊匹配保存失败:', e);
                    showToast('保存失败', 'error');
                }
                
                return;
            }
            
            // v5.5: 新建模式（从排除弹窗触发 或 v6.3 替换流程触发）
            if (!id) {
                const editedContent = await saveEdit();
                
                // 验证必填字段
                if (!editedContent.meaning) {
                    showToast('请填写含义', 'error');
                    return;
                }
                
                try {
                    // 根据类型决定入库位置
                    const itemType = document.getElementById('editItemType').value || 'word';
                    let apiUrl = '/api/vocabulary/words';
                    let apiData = {
                        word: originalText,
                        phonetic: editedContent.phonetic || '',
                        pos: editedContent.pos || '',
                        meaning: editedContent.meaning,
                        example: editedContent.example || '',
                        category: editedContent.category || '其他'
                    };
                    
                    if (itemType === 'phrase' || targetType === 'phrase') {
                        apiUrl = '/api/vocabulary/phrases';
                        apiData = {
                            phrase: originalText,
                            meaning: editedContent.meaning,
                            example: editedContent.example || '',
                            category: editedContent.category || '其他'
                        };
                    } else if (itemType === 'pattern' || targetType === 'pattern') {
                        apiUrl = '/api/vocabulary/patterns';
                        apiData = {
                            pattern: originalText,
                            meaning: editedContent.meaning,
                            example: editedContent.example || '',
                            category: editedContent.category || '其他'
                        };
                    }
                    
                    // v6.3.5: 入库前用精确检查接口
                    const checkRes = await fetch('/api/vocabulary/check-exists?text=' + encodeURIComponent(originalText) + '&type=' + itemType);
                    const checkData = await checkRes.json();
                    
                    if (checkData.success && checkData.exists) {
                        // 已存在，跳过入库
                        const existingItem = checkData.data;
                        const typeLabel = itemType === 'phrase' ? '短语' : itemType === 'pattern' ? '句型' : '单词';
                        showToast(`${typeLabel}"${originalText}"已在词库中，跳过`, 'warning');
                        closeModal('editModal', true);
                        
                        // 恢复弹窗状态
                        document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                        // v7.0: excludeBtn 已删除
                        
                        // 如果在替换流程中，更新状态并继续
                        if (window._pendingReplaceItems && window._pendingReplaceIndex < window._pendingReplaceItems.length) {
                            if (window._currentReplaceItem) {
                                window._currentReplaceItem.inVocab = true;
                                window._currentReplaceItem.vocabInfo = {
                                    id: existingItem.id,
                                    type: existingItem.type,
                                    meaning: existingItem.meaning
                                };
                                const idx = window._replaceSelected.findIndex(s => 
                                    s.text.toLowerCase() === window._currentReplaceItem.text.toLowerCase()
                                );
                                if (idx >= 0) {
                                    window._replaceSelected[idx].inVocab = true;
                                    window._replaceSelected[idx].vocabInfo = window._currentReplaceItem.vocabInfo;
                                }
                            }
                            window._pendingReplaceIndex++;
                            setTimeout(() => { processNextReplaceItem(); }, 300);
                            return;
                        }
                        
                        // 排除流程继续
                        if (window._pendingNewWords && window._pendingNewWordsIndex < window._pendingNewWords.length) {
                            setTimeout(() => { processNextNewWord(); }, 300);
                        } else {
                            window._pendingNewWords = null;
                            window._pendingNewWordsIndex = 0;
                            loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                            loadPendingUnmatched();
                        }
                        return;
                    }
                    
                    const wordRes = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(apiData)
                    });
                    const wordData = await wordRes.json();
                    
                    if (wordData.success) {
                        const typeLabel = itemType === 'phrase' ? '短语' : itemType === 'pattern' ? '句型' : '单词';
                        showToast(`入库成功！已添加${typeLabel}：${originalText}`, 'success');
                        closeModal('editModal', true);  // skipCheck=true 避免重复询问
                        
                        // 恢复弹窗标题和排除按钮
                        document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                        // v7.0: excludeBtn 已删除
                        
                        // v6.3: 检查是否在替换流程中
                        if (window._pendingReplaceItems && window._pendingReplaceIndex < window._pendingReplaceItems.length) {
                            // 更新当前词条的词库信息
                            if (window._currentReplaceItem) {
                                window._currentReplaceItem.inVocab = true;
                                window._currentReplaceItem.newlyAdded = true;  // 标记为新入库
                                window._currentReplaceItem.vocabInfo = {
                                    id: wordData.id,
                                    type: itemType,
                                    meaning: editedContent.meaning
                                };
                                // 同步更新 _replaceSelected 中的对应项
                                const idx = window._replaceSelected.findIndex(s => 
                                    s.text.toLowerCase() === window._currentReplaceItem.text.toLowerCase()
                                );
                                if (idx >= 0) {
                                    window._replaceSelected[idx].inVocab = true;
                                    window._replaceSelected[idx].newlyAdded = true;  // 标记为新入库
                                    window._replaceSelected[idx].vocabInfo = window._currentReplaceItem.vocabInfo;
                                }
                            }
                            
                            // 继续处理下一个
                            window._pendingReplaceIndex++;
                            setTimeout(() => {
                                processNextReplaceItem();
                            }, 300);
                            return;
                        }
                        
                        // 继续处理下一个待处理的单词（排除流程）
                        if (window._pendingNewWords && window._pendingNewWordsIndex < window._pendingNewWords.length) {
                            setTimeout(() => {
                                processNextNewWord();
                            }, 300);
                        } else {
                            // 清理状态
                            window._pendingNewWords = null;
                            window._pendingNewWordsIndex = 0;
                            window._aiGeneratedContent = null;
                            loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                            loadPendingUnmatched();
                        }
                    } else {
                        // v6.3.4: 检查是否是唯一约束冲突（已存在）
                        const errorMsg = wordData.error || '';
                        if (errorMsg.includes('UNIQUE constraint') || errorMsg.includes('已存在')) {
                            // 当作已存在处理，继续流程
                            const typeLabel = itemType === 'phrase' ? '短语' : itemType === 'pattern' ? '句型' : '单词';
                            showToast(`${typeLabel}"${originalText}"已在词库中，跳过`, 'warning');
                            closeModal('editModal', true);
                            
                            document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                            // v7.0: excludeBtn 已删除
                            
                            // 替换流程继续
                            if (window._pendingReplaceItems && window._pendingReplaceIndex < window._pendingReplaceItems.length) {
                                if (window._currentReplaceItem) {
                                    window._currentReplaceItem.inVocab = true;
                                    const idx = window._replaceSelected.findIndex(s => 
                                        s.text.toLowerCase() === window._currentReplaceItem.text.toLowerCase()
                                    );
                                    if (idx >= 0) {
                                        window._replaceSelected[idx].inVocab = true;
                                    }
                                }
                                window._pendingReplaceIndex++;
                                setTimeout(() => { processNextReplaceItem(); }, 300);
                                return;
                            }
                            
                            // 排除流程继续
                            if (window._pendingNewWords && window._pendingNewWordsIndex < window._pendingNewWords.length) {
                                setTimeout(() => { processNextNewWord(); }, 300);
                            } else {
                                window._pendingNewWords = null;
                                window._pendingNewWordsIndex = 0;
                                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                                loadPendingUnmatched();
                            }
                        } else {
                            showToast(errorMsg || '入库失败', 'error');
                        }
                    }
                } catch (e) {
                    console.error('入库失败:', e);
                    showToast('入库失败', 'error');
                }
                return;
            }
            
            // 正常模式：先保存再入库
            await saveEdit();
            await doImport(id, targetType);
        }
        
        // 直接入库
        async function importUnmatched(id) {
            if (!confirm('确定将此数据入库？')) return;
            await doImport(id);
        }
        
        async function doImport(id, targetType = null) {
            try {
                const res = await fetch(API_BASE + '/unmatched/' + id + '/import', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ targetType, reviewedBy: 'admin' })
                });
                const data = await res.json();
                if (data.success) {
                    // v5.6: 显示详细的入库位置
                    const dbInfo = getDbInfo(data.importedTo);
                    showToast(`入库成功！已添加到：${dbInfo}`, 'success');
                    closeModal('editModal');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadPendingUnmatched();
                } else {
                    showToast(data.error || '入库失败', 'error');
                }
            } catch (e) {
                showToast('入库失败', 'error');
            }
        }
        
        /**
         * v5.6: 获取数据库详细信息
         */
        function getDbInfo(importedTo) {
            const dbInfoMap = {
                'words': '词库管理 vocabulary.db → words 表',
                'phrases': '词库管理 vocabulary.db → phrases 表',
                'patterns': '词库管理 vocabulary.db → patterns 表',
                'grammar': '语法库管理 grammar.db → grammar 表'
            };
            return dbInfoMap[importedTo] || importedTo;
        }
        
        // 忽略
        async function ignoreUnmatched(id) {
            if (!confirm('确定忽略此数据？')) return;
            
            try {
                const res = await fetch(API_BASE + '/unmatched/' + id + '/ignore', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ reviewedBy: 'admin' })
                });
                const data = await res.json();
                if (data.success) {
                    showToast('已忽略', 'success');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadPendingUnmatched();
                } else {
                    showToast(data.error || '操作失败', 'error');
                }
            } catch (e) {
                showToast('操作失败', 'error');
            }
        }
        
        // ============================================
        // v5.5 新增：从编辑页面排除（不是短语/单词等）
        // ============================================
        
        /**
         * 拆分文本为单词列表，过滤占位符
         * "protect sth." → ["protect"]
         * "look after sb." → ["look", "after"]
         */
        function splitWordsForExtract(text) {
            if (!text) return [];
            
            // 只过滤简写占位符（保留 oneself、done、to do 等真正的单词）
            const placeholders = ['sth.', 'sth', 'sb.', 'sb', "one's"];
            
            // 按空格拆分
            const words = text.split(/\s+/).map(w => w.trim()).filter(w => w);
            
            // 过滤占位符
            return words.filter(w => {
                const lower = w.toLowerCase().replace(/[.,;:!?]$/, '');
                return !placeholders.includes(lower) && !placeholders.includes(w.toLowerCase());
            });
        }
        
        /**
         * v6.1 新增：从模糊匹配审核触发排除弹窗
         * 用于处理"不是短语/单词"的情况
         */
        function openExcludeModalFromReject(matchId, originalText, originalType) {
            // 保存 matchId 供后续使用
            window._rejectMatchId = matchId;
            
            // 填充数据
            document.getElementById('excludeItemId').value = '';  // 清空，表示来自模糊匹配
            document.getElementById('excludeOriginalText').value = originalText;
            document.getElementById('excludeOriginalType').value = originalType;
            
            // 清空AI内容（模糊匹配没有AI生成内容）
            window._aiGeneratedContent = null;
            
            // 显示信息
            document.getElementById('excludeDisplayText').textContent = originalText;
            document.getElementById('excludeDisplayText2').textContent = originalText;
            
            const typeLabel = getTypeLabel(originalType);
            document.getElementById('excludeDisplayType').textContent = `识别为：${typeLabel}`;
            document.getElementById('excludeDisplayType2').textContent = typeLabel;
            
            // 拆分单词并生成checkbox
            const words = splitWordsForExtract(originalText);
            const checkboxContainer = document.getElementById('extractWordCheckboxes');
            const noWordsMsg = document.getElementById('noWordsToExtract');
            
            if (words.length === 0) {
                checkboxContainer.innerHTML = '';
                checkboxContainer.style.display = 'none';
                noWordsMsg.style.display = 'block';
            } else {
                noWordsMsg.style.display = 'none';
                checkboxContainer.style.display = 'flex';
                checkboxContainer.innerHTML = words.map((word, idx) => `
                    <label style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: white; border: 1px solid #86efac; border-radius: 6px; cursor: pointer;">
                        <input type="checkbox" name="extractWord" value="${escapeHtml(word)}" style="width: 16px; height: 16px;">
                        <span style="color: #166534; font-weight: 500;">${escapeHtml(word)}</span>
                    </label>
                `).join('');
            }
            
            // 显示弹窗
            document.getElementById('excludeModal').classList.add('active');
        }
        
        /**
         * 打开排除弹窗
         */
        function openExcludeModal() {
            const id = document.getElementById('editItemId').value;
            const originalText = document.getElementById('editOriginalText').textContent;
            const itemType = document.getElementById('editItemType').value;
            
            // 填充数据
            document.getElementById('excludeItemId').value = id;
            document.getElementById('excludeOriginalText').value = originalText;
            document.getElementById('excludeOriginalType').value = itemType;
            
            // v5.6: 保存AI生成的内容，用于后续提取单词时预填
            window._aiGeneratedContent = {
                pos: document.getElementById('editPos').value || '',
                meaning: document.getElementById('editMeaning').value || '',
                example: document.getElementById('editExample').value || ''
            };
            console.log('[排除] 保存AI内容:', window._aiGeneratedContent);
            
            // 显示信息
            document.getElementById('excludeDisplayText').textContent = originalText;
            document.getElementById('excludeDisplayText2').textContent = originalText;
            
            const typeLabel = getTypeLabel(itemType);
            document.getElementById('excludeDisplayType').textContent = `识别为：${typeLabel}`;
            document.getElementById('excludeDisplayType2').textContent = typeLabel;
            
            // 拆分单词并生成checkbox
            const words = splitWordsForExtract(originalText);
            const checkboxContainer = document.getElementById('extractWordCheckboxes');
            const noWordsMsg = document.getElementById('noWordsToExtract');
            
            if (words.length === 0) {
                checkboxContainer.innerHTML = '';
                checkboxContainer.style.display = 'none';
                noWordsMsg.style.display = 'block';
            } else {
                noWordsMsg.style.display = 'none';
                checkboxContainer.style.display = 'flex';
                checkboxContainer.innerHTML = words.map((word, idx) => `
                    <label style="display: flex; align-items: center; gap: 6px; padding: 8px 12px; background: white; border: 1px solid #86efac; border-radius: 6px; cursor: pointer;">
                        <input type="checkbox" name="extractWord" value="${escapeHtml(word)}" style="width: 16px; height: 16px;">
                        <span style="color: #166534; font-weight: 500;">${escapeHtml(word)}</span>
                    </label>
                `).join('');
            }
            
            // 显示弹窗
            document.getElementById('excludeModal').classList.add('active');
        }
        
        /**
         * 执行排除操作（批量处理）
         * v7.0: 改为调用替换库API /api/matching-dict/exclude（排除库已合并）
         * v6.1: 支持从模糊匹配触发（需要标记原匹配为错误）
         */
        async function executeExcludeFromEdit() {
            const id = document.getElementById('excludeItemId').value;
            const originalText = document.getElementById('excludeOriginalText').value;
            const originalType = document.getElementById('excludeOriginalType').value;
            
            // v6.1: 检查是否来自模糊匹配
            const fromRejectMatch = window._rejectMatchId ? true : false;
            const rejectMatchId = window._rejectMatchId;
            
            // 获取勾选的单词
            const checkedWords = [];
            document.querySelectorAll('input[name="extractWord"]:checked').forEach(cb => {
                checkedWords.push(cb.value);
            });
            
            try {
                // 1. 添加到替换库（排除规则，target_text 为空）
                const excludeRes = await fetch('/api/matching-dict/exclude', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_text: originalText,
                        original_type: originalType,
                        notes: `不是${getTypeLabel(originalType)}`,
                        created_by: 'admin'
                    })
                });
                const excludeData = await excludeRes.json();
                
                if (!excludeData.success) {
                    showToast(excludeData.error || '排除失败', 'error');
                    return;
                }
                
                console.log(`[排除] 已添加到替换库(排除): ${originalText} (${originalType})`);
                showToast(`已添加到：替换库(排除规则)`, 'success');
                
                // 2. 根据来源标记原记录
                if (fromRejectMatch && rejectMatchId) {
                    // v6.1: 来自模糊匹配，标记原匹配记录为错误
                    await fetch(API_BASE + '/matches/' + rejectMatchId + '/reject', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            reviewedBy: 'admin', 
                            notes: checkedWords.length > 0 
                                ? `已排除，待提取: ${checkedWords.join(', ')}` 
                                : '已排除'
                        })
                    });
                    // 清理状态
                    window._rejectMatchId = null;
                } else if (id) {
                    // 来自编辑弹窗，标记原unmatched记录为已忽略
                    await fetch(API_BASE + '/unmatched/' + id + '/ignore', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            reviewedBy: 'admin',
                            notes: checkedWords.length > 0 
                                ? `已排除，待提取: ${checkedWords.join(', ')}` 
                                : '已排除'
                        })
                    });
                }
                
                // 3. 如果有勾选的单词，批量查询词库
                if (checkedWords.length > 0) {
                    // 查询词库中已存在的单词
                    const existingWords = [];
                    const newWords = [];
                    
                    for (const word of checkedWords) {
                        try {
                            // 搜索词库
                            const searchRes = await fetch(`/api/vocabulary/words?search=${encodeURIComponent(word)}&limit=100`);
                            const searchData = await searchRes.json();
                            
                            // 检查是否有精确匹配
                            let exists = false;
                            if (searchData.success && searchData.data) {
                                exists = searchData.data.some(item => 
                                    item.word && item.word.toLowerCase() === word.toLowerCase()
                                );
                            }
                            
                            if (exists) {
                                existingWords.push(word);
                            } else {
                                newWords.push(word);
                            }
                        } catch (e) {
                            console.warn(`[查询] 查询失败: ${word}`, e);
                            newWords.push(word);  // 查询失败当作不存在
                        }
                    }
                    
                    // 关闭排除弹窗
                    closeModal('excludeModal');
                    closeModal('editModal');
                    
                    // 提示已存在的单词
                    if (existingWords.length > 0) {
                        showToast(`词库已有: ${existingWords.join(', ')}，不需要重复入库`, 'success');
                    }
                    
                    // 处理新单词：逐个打开编辑弹窗
                    if (newWords.length > 0) {
                        // 保存待处理的新单词列表
                        window._pendingNewWords = newWords;
                        window._pendingNewWordsIndex = 0;
                        
                        // 开始处理第一个
                        setTimeout(() => {
                            processNextNewWord();
                        }, 500);
                    } else {
                        loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                        // v6.1: 根据来源刷新正确的列表
                        if (fromRejectMatch) {
                            loadPendingMatches();
                        } else {
                            loadPendingUnmatched();
                        }
                    }
                } else {
                    // 没有勾选任何单词，直接完成
                    closeModal('excludeModal');
                    closeModal('editModal');
                    showToast('已排除！下次不会再识别为' + getTypeLabel(originalType), 'success');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    // v6.1: 根据来源刷新正确的列表
                    if (fromRejectMatch) {
                        loadPendingMatches();
                    } else {
                        loadPendingUnmatched();
                    }
                }
                
            } catch (e) {
                console.error('排除操作失败:', e);
                showToast('操作失败', 'error');
                // v6.1: 清理状态
                window._rejectMatchId = null;
            }
        }

        // ============================================
        // v5.7 新增：替换功能（识别错误时使用）
        // ============================================

        /**
         * 打开替换弹窗
         */
        function openReplaceModal() {
            const id = document.getElementById('editItemId').value;
            const originalText = document.getElementById('editOriginalText').textContent;
            const itemType = document.getElementById('editItemType').value;

            document.getElementById('replaceItemId').value = id;
            document.getElementById('replaceItemType').value = itemType;
            document.getElementById('replaceOriginalText').textContent = originalText;
            document.getElementById('replaceNewText').value = '';
            document.getElementById('replacePreview').style.display = 'none';

            document.getElementById('replaceModal').classList.add('active');
        }

        /**
         * 预览替换匹配结果
         */
        async function previewReplace() {
            const newText = document.getElementById('replaceNewText').value.trim();
            const itemType = document.getElementById('replaceItemType').value;

            if (!newText) {
                showToast('请输入替换文本', 'error');
                return;
            }

            try {
                const res = await fetch('/api/replace/search-vocab', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: newText, type: itemType })
                });
                const data = await res.json();

                const previewDiv = document.getElementById('replacePreview');
                const contentDiv = document.getElementById('replacePreviewContent');

                if (data.success) {
                    previewDiv.style.display = 'block';
                    if (data.data.matched) {
                        contentDiv.innerHTML = `
                            ✅ 匹配成功！<br>
                            匹配到：<strong>${escapeHtml(data.data.matchedText)}</strong><br>
                            匹配度：${(data.data.score * 100).toFixed(0)}%<br>
                            位置：${data.data.sourceTable} #${data.data.sourceId}
                        `;
                        previewDiv.style.background = '#f0fdf4';
                        contentDiv.style.color = '#15803d';
                    } else {
                        contentDiv.innerHTML = `
                            ⚠️ 词库中未找到匹配<br>
                            将会创建新词条：<strong>${escapeHtml(newText)}</strong>
                        `;
                        previewDiv.style.background = '#fef3c7';
                        contentDiv.style.color = '#92400e';
                    }
                }
            } catch (e) {
                showToast('预览失败: ' + e.message, 'error');
            }
        }

        /**
         * 执行替换操作
         */
        window.executeReplace = async function executeReplace() {
            const id = document.getElementById('replaceItemId').value;
            const originalText = document.getElementById('replaceOriginalText').textContent;
            const itemType = document.getElementById('replaceItemType').value;
            const replaceText = document.getElementById('replaceNewText').value.trim();

            if (!replaceText) {
                showToast('请输入替换文本', 'error');
                return;
            }

            if (replaceText.toLowerCase() === originalText.toLowerCase()) {
                showToast('替换文本不能和原文相同', 'error');
                return;
            }

            try {
                // 1. 调用替换API（会自动匹配词库、入库、保存规则）
                const res = await fetch('/api/replace/execute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_text: originalText,
                        original_type: itemType,
                        replace_text: replaceText,
                        created_by: 'admin'
                    })
                });
                const data = await res.json();

                if (!data.success) {
                    showToast(data.error || '替换失败', 'error');
                    return;
                }

                // 2. 标记原记录为已忽略（带替换备注）
                if (id) {
                    await fetch(API_BASE + '/unmatched/' + id + '/ignore', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            reviewedBy: 'admin',
                            notes: `已替换为: ${replaceText}`
                        })
                    });
                }

                // 3. 显示成功信息
                const resultInfo = data.data;
                let successMsg = '替换成功！';
                if (resultInfo.matched) {
                    successMsg += ` 匹配到：${resultInfo.matchedText}`;
                } else {
                    successMsg += ` 已创建新词条`;
                }
                successMsg += `（${resultInfo.importedTo}#${resultInfo.importedId}）`;

                showToast(successMsg, 'success');

                // 4. 关闭弹窗并刷新
                closeModal('replaceModal');
                closeModal('editModal');
                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                loadPendingUnmatched();

            } catch (e) {
                console.error('替换失败:', e);
                showToast('替换失败: ' + e.message, 'error');
            }
        }

        // ============================================
        // v6.3.2 重构：替换功能（支持拖动组合短语）
        // ============================================

        // 常见虚词列表（不显示为选项）
        const FILTER_WORDS = new Set([
            'a', 'an', 'the', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'are', 'was', 'were', 'be', 'been', 'being',
            'sth', 'sb', 'sth.', 'sb.', "one's", 'doing', 'done', 'adj', 'adj.', 'adv', 'adv.', 'n.', 'v.', 'prep.', 'conj.',
            'it', 'its', 'this', 'that', 'these', 'those', 'my', 'your', 'his', 'her', 'our', 'their',
            'and', 'or', 'but', 'so', 'if', 'when', 'where', 'how', 'what', 'which', 'who', 'whom', 'whose',
            'can', 'could', 'will', 'would', 'shall', 'should', 'may', 'might', 'must',
            'do', 'does', 'did', 'have', 'has', 'had', 'get', 'got', 'gotten'
        ]);

        // 存储状态
        window._matchWordPool = [];      // 单词池 { text, inVocab, vocabInfo }
        window._matchBuilderWords = [];  // 组合区的单词
        window._matchSelectedItems = []; // 已选择的项 { text, type, inVocab, vocabInfo }

        /**
         * 打开替换弹窗 v6.3.2
         */
        async function openMatchModal() {
            const id = document.getElementById('editItemId').value;
            const originalText = document.getElementById('editOriginalText').textContent;
            const itemType = document.getElementById('editItemType').value;

            document.getElementById('matchItemId').value = id;
            document.getElementById('matchItemType').value = itemType;
            document.getElementById('matchOriginalText').textContent = originalText;
            
            // 重置状态
            window._matchWordPool = [];
            window._matchBuilderWords = [];
            window._matchSelectedItems = [];
            
            document.getElementById('matchModal').classList.add('active');
            
            // 分析原文
            await analyzeTextForOptions(originalText);
            
            // 添加点击外部区域关闭搜索结果的监听器
            setTimeout(() => {
                if (!window._searchClickHandlerAdded) {
                    document.addEventListener('click', handleSearchOutsideClick);
                    window._searchClickHandlerAdded = true;
                    console.log('[搜索] 已添加外部点击监听器');
                }
            }, 100);
        }
        
        /**
         * 处理点击搜索框外部区域，关闭搜索结果
         */
        function handleSearchOutsideClick(e) {
            // 获取统一搜索相关的元素
            const unifiedInput = document.getElementById('unifiedSearchInput');
            const unifiedResults = document.getElementById('unifiedSearchResults');
            
            // 检查点击是否是搜索按钮
            const isSearchButton = e.target.closest && (
                e.target.closest('button[onclick*="searchAllForMatch"]') || 
                e.target.closest('button[onclick*="searchGrammarLib"]')
            );
            
            // 如果是搜索按钮，不做任何处理
            if (isSearchButton) {
                return;
            }
            
            // 检查点击是否在搜索区域内
            const clickedInSearch = unifiedInput && (unifiedInput.contains(e.target) || unifiedResults.contains(e.target));
            
            // 如果点击在外部，关闭搜索结果
            if (!clickedInSearch && unifiedResults) {
                unifiedResults.style.display = 'none';
            }
        }

        /**
         * 分析原文，生成单词池
         */
        async function analyzeTextForOptions(originalText) {
            const poolContainer = document.getElementById('matchWordPool');
            poolContainer.innerHTML = '<span style="color: #0369a1; font-size: 13px;">分析中...</span>';
            
            try {
                // 1. 拆分单词
                const words = originalText.toLowerCase()
                    .replace(/[.,!?;:'"()]/g, '')
                    .split(/\s+/)
                    .filter(w => w.length > 0);
                
                // 2. 过滤虚词，保留有效单词
                const filteredOut = [];
                const validWords = [];
                const seen = new Set();
                
                for (const w of words) {
                    if (FILTER_WORDS.has(w.toLowerCase()) || w.length <= 2) {
                        filteredOut.push(w);
                    } else if (!seen.has(w.toLowerCase())) {
                        seen.add(w.toLowerCase());
                        validWords.push(w);
                    }
                }
                
                // 3. 检查每个单词是否在词库中
                window._matchWordPool = [];
                for (const word of validWords) {
                    const searchRes = await searchVocabQuick(word, 'word');
                    window._matchWordPool.push({
                        text: searchRes.found ? searchRes.text : word,
                        inVocab: searchRes.found,
                        vocabInfo: searchRes.info
                    });
                }
                
                // 4. 渲染
                renderWordPool();
                renderBuilderArea();
                renderSelectedItems();
                
                // 5. 显示过滤掉的词
                if (filteredOut.length > 0) {
                    document.getElementById('matchFilteredWords').textContent = 
                        '已过滤常见词：' + [...new Set(filteredOut)].join(', ');
                } else {
                    document.getElementById('matchFilteredWords').textContent = '';
                }
                
            } catch (e) {
                console.error('分析失败:', e);
                poolContainer.innerHTML = '<span style="color: #dc2626;">分析失败: ' + e.message + '</span>';
            }
        }

        /**
         * 快速搜索词库 v6.3.5 - 使用精确检查接口
         */
        async function searchVocabQuick(text, type) {
            try {
                // 使用精确检查接口
                const res = await fetch('/api/vocabulary/check-exists?text=' + encodeURIComponent(text) + '&type=' + type);
                const data = await res.json();
                
                if (data.success && data.exists && data.data) {
                    return {
                        found: true,
                        text: data.data.word || data.data.phrase || data.data.pattern || text,
                        info: { 
                            id: data.data.id, 
                            type: data.data.type, 
                            meaning: data.data.meaning 
                        }
                    };
                }
                return { found: false };
            } catch (e) {
                console.error('检查词库失败:', e);
                return { found: false };
            }
        }

        /**
         * 渲染单词池
         */
        function renderWordPool() {
            const container = document.getElementById('matchWordPool');
            
            if (window._matchWordPool.length === 0) {
                container.innerHTML = '<span style="color: #0369a1; font-size: 13px;">没有可用的单词</span>';
                return;
            }
            
            container.innerHTML = window._matchWordPool.map((word, idx) => `
                <span draggable="true" 
                      ondragstart="dragWord(event, ${idx})"
                      onclick="selectWord(${idx})"
                      style="display: inline-block; padding: 6px 12px; background: white; border: 1px solid #bae6fd; border-radius: 6px; cursor: pointer; font-weight: 500; color: #0c4a6e; user-select: none;"
                      onmouseover="this.style.background='#e0f2fe'; this.style.borderColor='#0369a1'"
                      onmouseout="this.style.background='white'; this.style.borderColor='#bae6fd'"
                      title="点击选中，或拖动到组合区">
                    ${escapeHtml(word.text)}
                </span>
            `).join('');
        }

        /**
         * 渲染组合区 - v6.4 支持输入框
         */
        function renderBuilderArea() {
            const container = document.getElementById('matchPhraseBuilder');
            const input = document.getElementById('builderInput');
            
            if (window._matchBuilderWords.length === 0) {
                // 保留输入框
                container.innerHTML = `<input type="text" id="builderInput" placeholder="拖入单词或直接输入..." 
                    style="flex: 1; min-width: 150px; border: none; background: transparent; outline: none; font-size: 14px; color: #5b21b6;"
                    onkeydown="if(event.key==='Enter'){buildPhrase(); event.preventDefault();}">`;
                return;
            }
            
            // 显示已拖入的单词 + 输入框
            let html = window._matchBuilderWords.map((word, idx) => `
                <span onclick="removeFromBuilder(${idx})"
                      style="display: inline-block; padding: 5px 10px; background: #ede9fe; border: 1px solid #c4b5fd; border-radius: 4px; cursor: pointer; font-weight: 500; color: #5b21b6;"
                      onmouseover="this.style.background='#fecaca'; this.style.borderColor='#f87171'"
                      onmouseout="this.style.background='#ede9fe'; this.style.borderColor='#c4b5fd'"
                      title="点击移除">
                    ${escapeHtml(word.text)} ✕
                </span>
            `).join('');
            
            // 末尾加上输入框
            html += `<input type="text" id="builderInput" placeholder="继续输入..." 
                style="flex: 1; min-width: 80px; border: none; background: transparent; outline: none; font-size: 14px; color: #5b21b6;"
                onkeydown="if(event.key==='Enter'){buildPhrase(); event.preventDefault();}">`;
            
            container.innerHTML = html;
        }

        /**
         * 渲染已选择项（v7.0: 分类显示单词/短语/语法）
         */
        function renderSelectedItems() {
            const container = document.getElementById('matchSelectedItems');
            const needMeaningTip = document.getElementById('matchNeedMeaningTip');
            
            if (window._matchSelectedItems.length === 0) {
                container.innerHTML = '<span style="color: #86efac; font-size: 13px;" id="selectedPlaceholder">点击单词或生成短语添加...</span>';
                needMeaningTip.style.display = 'none';
                return;
            }
            
            // v7.0: 分类
            const words = window._matchSelectedItems.filter(item => item.type === 'word');
            const phrases = window._matchSelectedItems.filter(item => item.type === 'phrase');
            const grammars = window._matchSelectedItems.filter(item => item.type === 'grammar');
            
            let html = '';
            
            // 单词区
            if (words.length > 0) {
                html += `<div style="width: 100%; margin-bottom: 8px;">
                    <div style="font-size: 11px; color: #1e40af; margin-bottom: 4px; font-weight: 600;">📚 单词 (${words.length})</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">`;
                html += words.map((item, idx) => {
                    const realIdx = window._matchSelectedItems.indexOf(item);
                    const statusIcon = item.inVocab ? '✓' : '✎';
                    const statusColor = item.inVocab ? '#22c55e' : '#f59e0b';
                    return `
                        <span style="display: inline-flex; align-items: center; gap: 4px; padding: 5px 10px; background: #dbeafe; border: 1px solid #93c5fd; border-radius: 6px; font-weight: 500; color: #1e40af; font-size: 13px;">
                            <span style="color: ${statusColor}; font-size: 10px;">${statusIcon}</span>
                            <span onclick="editSelectedItem(${realIdx})" 
                                  style="cursor: pointer; border-bottom: 1px dashed #1e40af;"
                                  title="点击编辑">${escapeHtml(item.text)}</span>
                            <span onclick="removeSelected(${realIdx})" 
                                  style="cursor: pointer; color: #ef4444; font-size: 12px; margin-left: 2px;"
                                  title="移除">×</span>
                        </span>`;
                }).join('');
                html += `</div></div>`;
            }
            
            // 短语区
            if (phrases.length > 0) {
                html += `<div style="width: 100%; margin-bottom: 8px;">
                    <div style="font-size: 11px; color: #5b21b6; margin-bottom: 4px; font-weight: 600;">📖 短语 (${phrases.length})</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">`;
                html += phrases.map((item, idx) => {
                    const realIdx = window._matchSelectedItems.indexOf(item);
                    const statusIcon = item.inVocab ? '✓' : '✎';
                    const statusColor = item.inVocab ? '#22c55e' : '#f59e0b';
                    return `
                        <span style="display: inline-flex; align-items: center; gap: 4px; padding: 5px 10px; background: #ede9fe; border: 1px solid #c4b5fd; border-radius: 6px; font-weight: 500; color: #5b21b6; font-size: 13px;">
                            <span style="color: ${statusColor}; font-size: 10px;">${statusIcon}</span>
                            <span onclick="editSelectedItem(${realIdx})" 
                                  style="cursor: pointer; border-bottom: 1px dashed #5b21b6;"
                                  title="点击编辑">${escapeHtml(item.text)}</span>
                            <span onclick="removeSelected(${realIdx})" 
                                  style="cursor: pointer; color: #ef4444; font-size: 12px; margin-left: 2px;"
                                  title="移除">×</span>
                        </span>`;
                }).join('');
                html += `</div></div>`;
            }
            
            // 语法区
            if (grammars.length > 0) {
                html += `<div style="width: 100%;">
                    <div style="font-size: 11px; color: #059669; margin-bottom: 4px; font-weight: 600;">📗 语法 (${grammars.length})</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 6px;">`;
                html += grammars.map((item, idx) => {
                    const realIdx = window._matchSelectedItems.indexOf(item);
                    const statusIcon = item.inVocab ? '✓' : '✎';
                    const statusColor = item.inVocab ? '#22c55e' : '#f59e0b';
                    return `
                        <span style="display: inline-flex; align-items: center; gap: 4px; padding: 5px 10px; background: #d1fae5; border: 1px solid #86efac; border-radius: 6px; font-weight: 500; color: #059669; font-size: 13px;">
                            <span style="color: ${statusColor}; font-size: 10px;">${statusIcon}</span>
                            <span onclick="editSelectedItem(${realIdx})" 
                                  style="cursor: pointer; border-bottom: 1px dashed #059669;"
                                  title="点击编辑">${escapeHtml(item.text)}</span>
                            <span onclick="removeSelected(${realIdx})" 
                                  style="cursor: pointer; color: #ef4444; font-size: 12px; margin-left: 2px;"
                                  title="移除">×</span>
                        </span>`;
                }).join('');
                html += `</div></div>`;
            }
            
            container.innerHTML = html;
            
            // 检查是否有未在词库的（需要重新检查，因为可能编辑过）
            checkSelectedItemsVocab();
        }

        /**
         * 编辑已选择项
         */
        function editSelectedItem(idx) {
            const item = window._matchSelectedItems[idx];
            if (!item) return;
            
            const newText = prompt('编辑文本：', item.text);
            if (newText === null || newText.trim() === '') return;
            
            const trimmedText = newText.trim();
            
            // 检查是否重复
            const duplicate = window._matchSelectedItems.some((it, i) => 
                i !== idx && it.text.toLowerCase() === trimmedText.toLowerCase()
            );
            if (duplicate) {
                showToast('该文本已存在', 'warning');
                return;
            }
            
            // 更新文本，并重置词库状态（需要重新检查）
            item.text = trimmedText;
            item.type = trimmedText.includes(' ') ? 'phrase' : 'word';
            item.inVocab = false;  // 重置，稍后检查
            item.vocabInfo = null;
            
            renderSelectedItems();
            showToast('已更新: ' + trimmedText, 'success');
        }

        /**
         * 检查已选择项的词库状态
         */
        async function checkSelectedItemsVocab() {
            const needMeaningTip = document.getElementById('matchNeedMeaningTip');
            let hasNew = false;
            
            for (const item of window._matchSelectedItems) {
                if (!item.inVocab && !item.vocabInfo) {
                    // 需要检查词库
                    const searchRes = await searchVocabQuick(item.text, item.type);
                    item.inVocab = searchRes.found;
                    item.vocabInfo = searchRes.info;
                }
                if (!item.inVocab) hasNew = true;
            }
            
            needMeaningTip.style.display = hasNew ? 'block' : 'none';
        }

        // ========== 拖拽相关函数 ==========
        
        function dragWord(event, idx) {
            event.dataTransfer.setData('text/plain', idx.toString());
            event.dataTransfer.effectAllowed = 'move';
        }
        
        function allowDrop(event) {
            event.preventDefault();
            event.currentTarget.style.borderColor = '#7c3aed';
            event.currentTarget.style.background = '#f3e8ff';
        }
        
        function leaveDrop(event) {
            event.currentTarget.style.borderColor = '#c4b5fd';
            event.currentTarget.style.background = '#faf5ff';
        }
        
        function dropToBuilder(event) {
            event.preventDefault();
            event.currentTarget.style.borderColor = '#c4b5fd';
            event.currentTarget.style.background = '#faf5ff';
            
            const idx = parseInt(event.dataTransfer.getData('text/plain'));
            if (isNaN(idx) || idx < 0 || idx >= window._matchWordPool.length) return;
            
            const word = window._matchWordPool[idx];
            
            // 检查是否已在组合区
            if (window._matchBuilderWords.some(w => w.text.toLowerCase() === word.text.toLowerCase())) {
                showToast('该单词已在组合区', 'warning');
                return;
            }
            
            window._matchBuilderWords.push({ ...word });
            renderBuilderArea();
        }

        // ========== 操作函数 ==========
        
        /**
         * 点击单词直接选中
         */
        async function selectWord(idx) {
            const word = window._matchWordPool[idx];
            if (!word) return;
            
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === word.text.toLowerCase() && item.type === 'word'
            )) {
                showToast('该单词已选择', 'warning');
                return;
            }
            
            window._matchSelectedItems.push({
                text: word.text,
                type: 'word',
                inVocab: word.inVocab,
                vocabInfo: word.vocabInfo
            });
            
            renderSelectedItems();
            showToast('已选择: ' + word.text, 'success');
        }
        
        /**
         * 从组合区移除
         */
        function removeFromBuilder(idx) {
            window._matchBuilderWords.splice(idx, 1);
            renderBuilderArea();
        }
        
        /**
         * 跳过并添加到排除库
         * 下次遇到相同文本时自动跳过，不展示、不上报
         */
        async function skipAndExclude() {
            const itemId = document.getElementById('matchItemId').value;
            const originalText = document.getElementById('matchOriginalText').textContent;
            const itemType = document.getElementById('matchItemType').value;
            
            if (!originalText) {
                showToast('缺少原始文本', 'error');
                return;
            }
            
            // 确认提示
            if (!confirm(`确定要跳过「${originalText}」吗？\n\n跳过后：\n• 此项将标记为已忽略\n• 添加到排除库\n• 下次处理时自动跳过`)) {
                return;
            }
            
            try {
                // 1. 添加到排除库
                const excludeRes = await fetch('/api/matching-dict/exclude', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_text: originalText,
                        original_type: itemType,
                        notes: '用户手动跳过',
                        created_by: 'admin'
                    })
                });
                const excludeData = await excludeRes.json();
                
                if (!excludeData.success) {
                    showToast('添加排除规则失败: ' + (excludeData.error || '未知错误'), 'error');
                    return;
                }
                
                // 2. 如果有 itemId，标记该未匹配记录为已忽略
                if (itemId) {
                    const ignoreRes = await fetch(API_BASE + `/unmatched/${itemId}/ignore`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            notes: '已添加到排除库，下次自动跳过'
                        })
                    });
                    const ignoreData = await ignoreRes.json();
                    if (!ignoreData.success) {
                        console.warn('标记忽略失败:', ignoreData.error);
                    }
                }
                
                showToast(`已跳过「${originalText}」，下次将自动跳过`, 'success');
                
                // 关闭弹窗并刷新列表
                closeModal('matchModal');
                closeModal('editModal', true);
                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                loadPendingUnmatched();
                
            } catch (e) {
                console.error('跳过失败:', e);
                showToast('跳过失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 生成短语 - v6.4 支持输入框输入
         */
        async function buildPhrase() {
            // 获取输入框内容
            const inputEl = document.getElementById('builderInput');
            const inputText = inputEl ? inputEl.value.trim() : '';
            
            // 组合：拖入的单词 + 输入框的内容
            let phraseText = '';
            if (window._matchBuilderWords.length > 0) {
                phraseText = window._matchBuilderWords.map(w => w.text).join(' ');
                if (inputText) {
                    phraseText += ' ' + inputText;
                }
            } else if (inputText) {
                phraseText = inputText;
            } else {
                showToast('请拖入单词或输入文本', 'warning');
                return;
            }
            
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === phraseText.toLowerCase()
            )) {
                showToast('该短语已选择', 'warning');
                return;
            }
            
            // 搜索词库
            const searchRes = await searchVocabQuick(phraseText, 'phrase');
            
            window._matchSelectedItems.push({
                text: searchRes.found ? searchRes.text : phraseText,
                type: 'phrase',
                inVocab: searchRes.found,
                vocabInfo: searchRes.info
            });
            
            // 清空组合区和输入框
            window._matchBuilderWords = [];
            renderBuilderArea();
            renderSelectedItems();
            
            showToast('已生成短语: ' + phraseText, 'success');
        }
        
        /**
         * v6.4 新增：搜索词库（模糊搜索）
         */
        async function searchVocabForMatch() {
            const searchInput = document.getElementById('vocabSearchInput');
            const keyword = searchInput.value.trim();
            const resultsDiv = document.getElementById('vocabSearchResults');
            
            if (!keyword) {
                showToast('请输入搜索关键词', 'warning');
                return;
            }
            
            try {
                // 同时搜索单词和短语
                const [wordsRes, phrasesRes, patternsRes] = await Promise.all([
                    fetch(`/api/vocabulary/words?search=${encodeURIComponent(keyword)}&limit=20`).then(r => r.json()),
                    fetch(`/api/vocabulary/phrases?search=${encodeURIComponent(keyword)}&limit=20`).then(r => r.json()),
                    fetch(`/api/vocabulary/patterns?search=${encodeURIComponent(keyword)}&limit=10`).then(r => r.json())
                ]);
                
                let html = '';
                let totalCount = 0;
                
                // 显示单词结果
                if (wordsRes.success && wordsRes.data && wordsRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #f0f9ff; font-size: 12px; color: #0369a1; font-weight: 600;">📝 单词 (' + wordsRes.data.length + ')</div>';
                    wordsRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="selectSearchResult('${escapeJs(item.word)}', 'word', ${item.id}, '${escapeJs(item.meaning || '')}')"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.word)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                // 显示短语结果
                if (phrasesRes.success && phrasesRes.data && phrasesRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #faf5ff; font-size: 12px; color: #7c3aed; font-weight: 600;">🔗 短语 (' + phrasesRes.data.length + ')</div>';
                    phrasesRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="selectSearchResult('${escapeJs(item.phrase)}', 'phrase', ${item.id}, '${escapeJs(item.meaning || '')}')"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.phrase)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                // 显示句型结果
                if (patternsRes.success && patternsRes.data && patternsRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #fef3c7; font-size: 12px; color: #92400e; font-weight: 600;">📐 句型 (' + patternsRes.data.length + ')</div>';
                    patternsRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="selectSearchResult('${escapeJs(item.pattern)}', 'pattern', ${item.id}, '${escapeJs(item.meaning || '')}')"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.pattern)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                if (totalCount === 0) {
                    html = '<div style="padding: 20px; text-align: center; color: #9ca3af;">未找到相关结果</div>';
                }
                
                resultsDiv.innerHTML = html;
                resultsDiv.style.display = 'block';
                
            } catch (e) {
                console.error('搜索词库失败:', e);
                showToast('搜索失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 统一搜索：同时搜索词库、语法库、替换库
         */
        window.searchAllForMatch = async function searchAllForMatch() {
            const searchInput = document.getElementById('unifiedSearchInput');
            const keyword = searchInput.value.trim();
            const resultsDiv = document.getElementById('unifiedSearchResults');
            
            if (!keyword) {
                showToast('请输入搜索关键词', 'warning');
                return;
            }
            
            try {
                resultsDiv.innerHTML = '<div style="padding: 16px; text-align: center; color: #0891b2;">搜索中...</div>';
                resultsDiv.style.display = 'block';
                
                // 并行搜索三个库
                const [wordsRes, phrasesRes, patternsRes, grammarRes, replaceRes] = await Promise.all([
                    fetch(`/api/vocabulary/words?search=${encodeURIComponent(keyword)}&limit=15`).then(r => r.json()),
                    fetch(`/api/vocabulary/phrases?search=${encodeURIComponent(keyword)}&limit=15`).then(r => r.json()),
                    fetch(`/api/vocabulary/patterns?search=${encodeURIComponent(keyword)}&limit=10`).then(r => r.json()),
                    fetch(`/api/grammar?search=${encodeURIComponent(keyword)}&limit=50`).then(r => r.json()),
                    fetch(`/api/matching-dict/rules?search=${encodeURIComponent(keyword)}&limit=15`).then(r => r.json())
                ]);
                
                let html = '';
                let totalCount = 0;
                
                // 1. 显示单词结果
                if (wordsRes.success && wordsRes.data && wordsRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #f0f9ff; font-size: 12px; color: #0369a1; font-weight: 600; border-bottom: 1px solid #bae6fd;">📝 单词 (' + wordsRes.data.length + ')</div>';
                    wordsRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="window.selectUnifiedResult('${escapeJs(item.word)}', 'word', ${item.id}, '${escapeJs(item.meaning || '')}', true)"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.word)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                // 2. 显示短语结果
                if (phrasesRes.success && phrasesRes.data && phrasesRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #faf5ff; font-size: 12px; color: #7c3aed; font-weight: 600; border-bottom: 1px solid #e9d5ff;">🔗 短语 (' + phrasesRes.data.length + ')</div>';
                    phrasesRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="window.selectUnifiedResult('${escapeJs(item.phrase)}', 'phrase', ${item.id}, '${escapeJs(item.meaning || '')}', true)"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.phrase)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                // 3. 显示句型结果
                if (patternsRes.success && patternsRes.data && patternsRes.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #fef3c7; font-size: 12px; color: #92400e; font-weight: 600; border-bottom: 1px solid #fde68a;">📐 句型 (' + patternsRes.data.length + ')</div>';
                    patternsRes.data.forEach(item => {
                        totalCount++;
                        html += `
                            <div onclick="window.selectUnifiedResult('${escapeJs(item.pattern)}', 'pattern', ${item.id}, '${escapeJs(item.meaning || '')}', true)"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0; display: flex; justify-content: space-between; align-items: center;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <span style="font-weight: 500;">${escapeHtml(item.pattern)}</span>
                                <span style="font-size: 12px; color: #6b7280;">${escapeHtml(item.meaning || '').substring(0, 30)}</span>
                            </div>`;
                    });
                }
                
                // 4. 显示语法结果（带关键词过滤）
                if (grammarRes.success && grammarRes.data && grammarRes.data.length > 0) {
                    // 过滤和排序
                    let filteredGrammar = grammarRes.data.filter(item => {
                        const titleMatch = item.title && item.title.toLowerCase().includes(keyword.toLowerCase());
                        const keywordsMatch = item.keywords && item.keywords.some(kw => 
                            kw.toLowerCase().includes(keyword.toLowerCase())
                        );
                        return titleMatch || keywordsMatch;
                    });
                    
                    filteredGrammar.sort((a, b) => {
                        const aKeywordExact = a.keywords && a.keywords.some(kw => 
                            kw.toLowerCase() === keyword.toLowerCase()
                        );
                        const bKeywordExact = b.keywords && b.keywords.some(kw => 
                            kw.toLowerCase() === keyword.toLowerCase()
                        );
                        if (aKeywordExact && !bKeywordExact) return -1;
                        if (!aKeywordExact && bKeywordExact) return 1;
                        return 0;
                    });
                    
                    filteredGrammar = filteredGrammar.slice(0, 10);
                    
                    if (filteredGrammar.length > 0) {
                        html += '<div style="padding: 8px 12px; background: #faf5ff; font-size: 12px; color: #7c3aed; font-weight: 600; border-bottom: 1px solid #e9d5ff;">📚 语法 (' + filteredGrammar.length + ')</div>';
                        filteredGrammar.forEach(item => {
                            totalCount++;
                            const matchedKeywords = item.keywords ? item.keywords.filter(kw => 
                                kw.toLowerCase().includes(keyword.toLowerCase())
                            ).slice(0, 2).join(', ') : '';
                            
                            html += `
                                <div onclick="window.selectUnifiedResult('${escapeJs(item.title)}', 'grammar', ${item.id}, '${escapeJs(item.definition || '')}', true)"
                                     style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;"
                                     onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                    <div style="font-weight: 500; margin-bottom: 2px;">${escapeHtml(item.title)}</div>
                                    ${matchedKeywords ? `<div style="font-size: 11px; color: #7c3aed; margin-bottom: 2px;">🏷️ ${escapeHtml(matchedKeywords)}</div>` : ''}
                                    <div style="font-size: 12px; color: #6b7280;">${escapeHtml(item.definition || '').substring(0, 40)}...</div>
                                </div>`;
                        });
                    }
                }
                
                // 5. 显示替换库结果（只显示有target_text的）
                if (replaceRes.success && replaceRes.data && replaceRes.data.length > 0) {
                    const validReplaces = replaceRes.data.filter(item => item.target_text && item.target_text.trim());
                    if (validReplaces.length > 0) {
                        html += '<div style="padding: 8px 12px; background: #fef3c7; font-size: 12px; color: #f59e0b; font-weight: 600; border-bottom: 1px solid #fde68a;">🔄 替换规则 (' + validReplaces.length + ')</div>';
                        validReplaces.forEach(item => {
                            totalCount++;
                            
                            // 容错处理：如果target_text是JSON格式，自动提取text字段
                            let displayTargetText = item.target_text;
                            try {
                                // 检测是否是JSON格式（以 [{ 或 {" 开头）
                                if (displayTargetText.trim().startsWith('[{') || displayTargetText.trim().startsWith('{"')) {
                                    const parsed = JSON.parse(displayTargetText);
                                    // 如果是数组，取第一个元素的text
                                    if (Array.isArray(parsed) && parsed.length > 0 && parsed[0].text) {
                                        displayTargetText = parsed[0].text;
                                    }
                                    // 如果是对象，直接取text
                                    else if (parsed.text) {
                                        displayTargetText = parsed.text;
                                    }
                                }
                            } catch (e) {
                                // JSON解析失败，使用原值（不影响正常数据）
                            }
                            
                            html += `
                                <div onclick="window.selectUnifiedResultReplace('${escapeJs(item.original_text)}', '${escapeJs(displayTargetText)}', '${escapeJs(item.original_type)}')"
                                     style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #f0f0f0;"
                                     onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 2px;">
                                        <span style="font-weight: 500;">${escapeHtml(item.original_text)}</span>
                                        <span style="color: #f59e0b;">→</span>
                                        <span style="color: #059669; font-weight: 500;">${escapeHtml(displayTargetText)}</span>
                                    </div>
                                    <div style="font-size: 11px; color: #9ca3af;">类型: ${item.original_type}</div>
                                </div>`;
                        });
                    }
                }
                
                if (totalCount === 0) {
                    html = '<div style="padding: 20px; text-align: center; color: #9ca3af;">未找到"' + escapeHtml(keyword) + '"相关的结果</div>';
                } else {
                    html = `<div style="padding: 8px 12px; background: #ecfdf5; font-size: 12px; color: #059669; font-weight: 600; border-bottom: 2px solid #10b981;">找到 ${totalCount} 条结果</div>` + html;
                }
                
                resultsDiv.innerHTML = html;
                
            } catch (e) {
                console.error('统一搜索失败:', e);
                resultsDiv.innerHTML = '<div style="padding: 20px; text-align: center; color: #dc2626;">搜索失败: ' + e.message + '</div>';
                showToast('搜索失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 选择统一搜索结果（词库/语法库）
         */
        window.selectUnifiedResult = function selectUnifiedResult(text, type, id, meaning, inVocab) {
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === text.toLowerCase()
            )) {
                showToast('该项已选择', 'warning');
                return;
            }
            
            window._matchSelectedItems.push({
                text: text,
                type: type,
                inVocab: inVocab,
                vocabInfo: { id: id, type: type, meaning: meaning }
            });
            
            renderSelectedItems();
            showToast('已选择: ' + text, 'success');
            
            // 隐藏搜索结果
            document.getElementById('unifiedSearchResults').style.display = 'none';
            document.getElementById('unifiedSearchInput').value = '';
        }
        
        /**
         * 选择统一搜索结果（替换库）
         */
        window.selectUnifiedResultReplace = async function selectUnifiedResultReplace(originalText, targetText, type) {
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === targetText.toLowerCase()
            )) {
                showToast('该项已选择', 'warning');
                return;
            }
            
            try {
                let searchRes;
                
                // 对于grammar类型，直接查询grammar表
                if (type === 'grammar') {
                    showToast('正在查询语法库...', 'info');
                    const response = await fetch(`/api/grammar?search=${encodeURIComponent(targetText)}`);
                    const result = await response.json();
                    
                    // 正确的数据路径是 result.data，不是 result.items
                    const items = result.data || result.items || [];
                    
                    // 查找精确匹配
                    const exactMatch = items.find(item => item.title === targetText);
                    
                    if (exactMatch) {
                        searchRes = {
                            found: true,
                            info: {
                                id: exactMatch.id,
                                type: 'grammar',
                                meaning: exactMatch.definition || exactMatch.title
                            }
                        };
                    } else {
                        searchRes = { found: false, info: null };
                    }
                } else {
                    // 对于非grammar类型，使用原来的searchVocabQuick
                    showToast('正在查询词库...', 'info');
                    searchRes = await searchVocabQuick(targetText, type);
                }
                
                window._matchSelectedItems.push({
                    text: targetText,
                    type: type,
                    inVocab: searchRes.found,
                    vocabInfo: searchRes.info,
                    replaceRule: { original: originalText, target: targetText }
                });
                
                renderSelectedItems();
                
                if (searchRes.found) {
                    showToast('已选择: ' + targetText + ' (词库已有)', 'success');
                } else {
                    showToast('已选择: ' + targetText + ' (需补充信息)', 'warning');
                }
                
                // 隐藏搜索结果
                document.getElementById('unifiedSearchResults').style.display = 'none';
                document.getElementById('unifiedSearchInput').value = '';
                
            } catch (e) {
                console.error('查询词库失败:', e);
                // 如果查询失败，按不在词库处理
                window._matchSelectedItems.push({
                    text: targetText,
                    type: type,
                    inVocab: false,
                    replaceRule: { original: originalText, target: targetText }
                });
                
                renderSelectedItems();
                showToast('已选择: ' + targetText, 'success');
                
                document.getElementById('unifiedSearchResults').style.display = 'none';
                document.getElementById('unifiedSearchInput').value = '';
            }
        }
        
        /**
         * v6.4 新增：选择搜索结果
         */
        function selectSearchResult(text, type, id, meaning) {
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === text.toLowerCase()
            )) {
                showToast('该项已选择', 'warning');
                return;
            }
            
            window._matchSelectedItems.push({
                text: text,
                type: type,
                inVocab: true,
                vocabInfo: { id: id, type: type, meaning: meaning }
            });
            
            renderSelectedItems();
            showToast('已选择: ' + text, 'success');
            
            // 隐藏搜索结果
            document.getElementById('vocabSearchResults').style.display = 'none';
            document.getElementById('vocabSearchInput').value = '';
        }
        
        /**
         * 新增：搜索语法库（改进版 - 更精准）
         */
        async function searchGrammarForMatch() {
            const searchInput = document.getElementById('grammarSearchInputMatch');
            const keyword = searchInput.value.trim();
            const resultsDiv = document.getElementById('grammarSearchResultsMatch');
            
            if (!keyword) {
                showToast('请输入搜索关键词', 'warning');
                return;
            }
            
            try {
                // 改进：同时搜索title和keywords，使用keywords字段更精准
                const res = await fetch(`/api/grammar?search=${encodeURIComponent(keyword)}&limit=50`);
                const data = await res.json();
                
                let html = '';
                let filteredResults = [];
                
                if (data.success && data.data && data.data.length > 0) {
                    // 过滤：优先显示关键词匹配的，然后是标题匹配的
                    filteredResults = data.data.filter(item => {
                        const titleMatch = item.title && item.title.toLowerCase().includes(keyword.toLowerCase());
                        const keywordsMatch = item.keywords && item.keywords.some(kw => 
                            kw.toLowerCase().includes(keyword.toLowerCase())
                        );
                        return titleMatch || keywordsMatch;
                    });
                    
                    // 排序：关键词精确匹配优先
                    filteredResults.sort((a, b) => {
                        const aKeywordExact = a.keywords && a.keywords.some(kw => 
                            kw.toLowerCase() === keyword.toLowerCase()
                        );
                        const bKeywordExact = b.keywords && b.keywords.some(kw => 
                            kw.toLowerCase() === keyword.toLowerCase()
                        );
                        if (aKeywordExact && !bKeywordExact) return -1;
                        if (!aKeywordExact && bKeywordExact) return 1;
                        return 0;
                    });
                    
                    // 限制最多显示20条
                    filteredResults = filteredResults.slice(0, 20);
                }
                
                if (filteredResults.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #faf5ff; font-size: 12px; color: #7c3aed; font-weight: 600;">📚 语法 (' + filteredResults.length + ')</div>';
                    filteredResults.forEach(item => {
                        // 显示匹配的关键词
                        const matchedKeywords = item.keywords ? item.keywords.filter(kw => 
                            kw.toLowerCase().includes(keyword.toLowerCase())
                        ).slice(0, 3).join(', ') : '';
                        
                        html += `
                            <div onclick="selectGrammarResult('${escapeJs(item.title)}', ${item.id}, '${escapeJs(item.definition || '')}')"
                                 style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5;"
                                 onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                <div style="font-weight: 500; margin-bottom: 4px;">${escapeHtml(item.title)}</div>
                                ${matchedKeywords ? `<div style="font-size: 11px; color: #7c3aed; margin-bottom: 2px;">🏷️ ${escapeHtml(matchedKeywords)}</div>` : ''}
                                <div style="font-size: 12px; color: #6b7280;">${escapeHtml(item.definition || '').substring(0, 50)}...</div>
                            </div>`;
                    });
                } else {
                    html = '<div style="padding: 20px; text-align: center; color: #9ca3af;">未找到包含"' + escapeHtml(keyword) + '"的语法</div>';
                }
                
                resultsDiv.innerHTML = html;
                resultsDiv.style.display = 'block';
                
            } catch (e) {
                console.error('搜索语法库失败:', e);
                showToast('搜索失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 选择语法搜索结果
         */
        function selectGrammarResult(title, id, definition) {
            // 检查是否已选择
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === title.toLowerCase()
            )) {
                showToast('该项已选择', 'warning');
                return;
            }
            
            window._matchSelectedItems.push({
                text: title,
                type: 'grammar',
                inVocab: true,
                vocabInfo: { id: id, type: 'grammar', meaning: definition }
            });
            
            renderSelectedItems();
            showToast('已选择: ' + title, 'success');
            
            // 隐藏搜索结果
            document.getElementById('grammarSearchResultsMatch').style.display = 'none';
            document.getElementById('grammarSearchInputMatch').value = '';
        }
        
        /**
         * 新增：搜索替换库
         */
        async function searchReplaceForMatch() {
            const searchInput = document.getElementById('replaceSearchInput');
            const keyword = searchInput.value.trim();
            const resultsDiv = document.getElementById('replaceSearchResults');
            
            if (!keyword) {
                showToast('请输入搜索关键词', 'warning');
                return;
            }
            
            try {
                const res = await fetch(`/api/matching-dict/rules?search=${encodeURIComponent(keyword)}&limit=20`);
                const data = await res.json();
                
                let html = '';
                
                if (data.success && data.data && data.data.length > 0) {
                    html += '<div style="padding: 8px 12px; background: #fef3c7; font-size: 12px; color: #f59e0b; font-weight: 600;">🔄 替换规则 (' + data.data.length + ')</div>';
                    data.data.forEach(item => {
                        // 只显示有target_text的替换规则，跳过排除规则
                        if (item.target_text && item.target_text.trim()) {
                            html += `
                                <div onclick="selectReplaceResult('${escapeJs(item.original_text)}', '${escapeJs(item.target_text)}', '${escapeJs(item.original_type)}')"
                                     style="padding: 10px 12px; cursor: pointer; border-bottom: 1px solid #e5e5e5;"
                                     onmouseover="this.style.background='#f0fdf4'" onmouseout="this.style.background='white'">
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                                        <span style="font-weight: 500;">${escapeHtml(item.original_text)}</span>
                                        <span style="color: #f59e0b;">→</span>
                                        <span style="color: #059669; font-weight: 500;">${escapeHtml(item.target_text)}</span>
                                    </div>
                                    <div style="font-size: 11px; color: #9ca3af;">类型: ${item.original_type}</div>
                                </div>`;
                        }
                    });
                    
                    if (!html.includes('onclick=')) {
                        html = '<div style="padding: 20px; text-align: center; color: #9ca3af;">未找到可用的替换规则</div>';
                    }
                } else {
                    html = '<div style="padding: 20px; text-align: center; color: #9ca3af;">未找到相关替换规则</div>';
                }
                
                resultsDiv.innerHTML = html;
                resultsDiv.style.display = 'block';
                
            } catch (e) {
                console.error('搜索替换库失败:', e);
                showToast('搜索失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 选择替换规则结果（改进版 - 自动查询词库）
         */
        async function selectReplaceResult(originalText, targetText, type) {
            // 使用targetText作为选择的内容
            if (window._matchSelectedItems.some(item => 
                item.text.toLowerCase() === targetText.toLowerCase()
            )) {
                showToast('该项已选择', 'warning');
                return;
            }
            
            try {
                // 查询targetText是否在词库中
                showToast('正在查询词库...', 'info');
                const searchRes = await searchVocabQuick(targetText, type);
                
                window._matchSelectedItems.push({
                    text: targetText,
                    type: type,
                    inVocab: searchRes.found,
                    vocabInfo: searchRes.info,
                    replaceRule: { original: originalText, target: targetText }
                });
                
                renderSelectedItems();
                
                if (searchRes.found) {
                    showToast('已选择: ' + targetText + ' (词库已有)', 'success');
                } else {
                    showToast('已选择: ' + targetText + ' (需补充信息)', 'warning');
                }
                
                // 隐藏搜索结果
                document.getElementById('replaceSearchResults').style.display = 'none';
                document.getElementById('replaceSearchInput').value = '';
                
            } catch (e) {
                console.error('查询词库失败:', e);
                // 如果查询失败，按不在词库处理
                window._matchSelectedItems.push({
                    text: targetText,
                    type: type,
                    inVocab: false,
                    replaceRule: { original: originalText, target: targetText }
                });
                
                renderSelectedItems();
                showToast('已选择: ' + targetText, 'success');
                
                document.getElementById('replaceSearchResults').style.display = 'none';
                document.getElementById('replaceSearchInput').value = '';
            }
        }
        
        /**
         * 移除已选择项
         */
        function removeSelected(idx) {
            const removed = window._matchSelectedItems.splice(idx, 1)[0];
            renderSelectedItems();
            showToast('已移除: ' + removed.text, 'info');
        }

        /**
         * 执行替换操作 v7.0 - 使用批量填写弹窗
         */
        async function executeMatchNew() {
            const id = document.getElementById('matchItemId').value;
            const originalText = document.getElementById('matchOriginalText').textContent;
            const itemType = document.getElementById('matchItemType').value;
            
            if (window._matchSelectedItems.length === 0) {
                showToast('请至少选择一项', 'error');
                return;
            }
            
            try {
                // 1. 检查所有项的词库状态
                showToast('正在检查词库...', 'info');
                
                const existItems = [];   // 词库已有
                const newItems = [];     // 需要新建
                
                for (const item of window._matchSelectedItems) {
                    // 如果已经标记为在词库中（通过搜索选择的），跳过检查
                    if (item.inVocab && item.vocabInfo && item.vocabInfo.id) {
                        existItems.push(item);
                        console.log(`[替换] 已确认在库: ${item.text} (${item.type})`);
                        continue;
                    }
                    
                    // 否则进行词库检查
                    const searchRes = await searchVocabQuick(item.text, item.type);
                    item.inVocab = searchRes.found;
                    item.vocabInfo = searchRes.info;
                    
                    if (searchRes.found) {
                        existItems.push(item);
                        console.log(`[替换] 检查后确认: ${item.text} (${item.type})`);
                    } else {
                        newItems.push(item);
                        console.log(`[替换] 需要新建: ${item.text} (${item.type})`);
                    }
                }
                
                // 更新显示
                renderSelectedItems();
                
                console.log(`[替换] 已有: ${existItems.length}, 需新建: ${newItems.length}`);
                
                // 2. 如果有需要新建的，打开批量填写弹窗
                if (newItems.length > 0) {
                    // 保存状态
                    window._batchFillContext = {
                        originalText,
                        itemType,
                        id,
                        existItems,
                        newItems,
                        allItems: [...window._matchSelectedItems]
                    };
                    
                    openBatchFillModal(newItems);
                    return;
                }
                
                // 3. 所有词条都在词库中，直接保存
                console.log('[替换] 所有词条都在词库中，直接保存替换规则');
                await saveReplaceRuleV2(originalText, itemType, id, window._matchSelectedItems);
                
            } catch (e) {
                console.error('替换操作失败:', e);
                showToast('操作失败: ' + e.message, 'error');
            }
        }
        
        /**
         * v7.0: 打开批量填写弹窗
         */
        function openBatchFillModal(newItems) {
            const container = document.getElementById('batchFillItems');
            
            container.innerHTML = newItems.map((item, idx) => {
                const typeLabel = item.type === 'word' ? '单词' : (item.type === 'phrase' ? '短语' : '语法');
                const typeColor = item.type === 'word' ? '#1e40af' : (item.type === 'phrase' ? '#5b21b6' : '#059669');
                const typeBg = item.type === 'word' ? '#dbeafe' : (item.type === 'phrase' ? '#ede9fe' : '#d1fae5');
                
                return `
                <div class="batch-fill-item" style="background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 10px; padding: 16px; margin-bottom: 12px;" data-idx="${idx}">
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px;">
                        <span style="background: ${typeBg}; color: ${typeColor}; padding: 4px 10px; border-radius: 4px; font-size: 12px; font-weight: 600;">${typeLabel}</span>
                        <span style="font-size: 16px; font-weight: 600; color: #1f2937;">${escapeHtml(item.text)}</span>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div>
                            <label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 4px;">中文含义 <span style="color: #ef4444;">*</span></label>
                            <input type="text" class="batch-meaning" data-idx="${idx}" placeholder="输入中文含义..." 
                                style="width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 4px;">例句（选填）</label>
                            <input type="text" class="batch-example" data-idx="${idx}" placeholder="输入例句..." 
                                style="width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        </div>
                        ${item.type === 'word' ? `
                        <div>
                            <label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 4px;">音标（选填）</label>
                            <input type="text" class="batch-phonetic" data-idx="${idx}" placeholder="如 /ˈæpl/" 
                                style="width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; color: #6b7280; margin-bottom: 4px;">词性（选填）</label>
                            <input type="text" class="batch-pos" data-idx="${idx}" placeholder="如 n. / v. / adj." 
                                style="width: 100%; padding: 8px 10px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 13px; box-sizing: border-box;">
                        </div>
                        ` : ''}
                    </div>
                </div>
                `;
            }).join('');
            
            document.getElementById('batchFillModal').classList.add('active');
        }
        
        /**
         * v7.0: 提交批量填写
         */
        async function submitBatchFill() {
            const ctx = window._batchFillContext;
            if (!ctx) {
                showToast('状态丢失，请重试', 'error');
                return;
            }
            
            // 1. 收集填写的数据
            const filledItems = [];
            let hasError = false;
            
            ctx.newItems.forEach((item, idx) => {
                const meaning = document.querySelector(`.batch-meaning[data-idx="${idx}"]`)?.value?.trim();
                const example = document.querySelector(`.batch-example[data-idx="${idx}"]`)?.value?.trim();
                const phonetic = document.querySelector(`.batch-phonetic[data-idx="${idx}"]`)?.value?.trim();
                const pos = document.querySelector(`.batch-pos[data-idx="${idx}"]`)?.value?.trim();
                
                if (!meaning) {
                    hasError = true;
                    document.querySelector(`.batch-meaning[data-idx="${idx}"]`).style.borderColor = '#ef4444';
                } else {
                    document.querySelector(`.batch-meaning[data-idx="${idx}"]`).style.borderColor = '#d1d5db';
                }
                
                filledItems.push({
                    ...item,
                    meaning,
                    example,
                    phonetic,
                    pos
                });
            });
            
            if (hasError) {
                showToast('请填写所有必填项（中文含义）', 'error');
                return;
            }
            
            try {
                showToast('正在保存...', 'info');
                
                // 2. 把新词条入库到词库
                for (const item of filledItems) {
                    let url = '';
                    let body = {};
                    
                    if (item.type === 'word') {
                        url = '/api/vocabulary/words';
                        body = {
                            word: item.text,
                            meaning: item.meaning,
                            phonetic: item.phonetic || '',
                            pos: item.pos || '',
                            example: item.example || ''
                        };
                    } else if (item.type === 'phrase') {
                        url = '/api/vocabulary/phrases';
                        body = {
                            phrase: item.text,
                            meaning: item.meaning,
                            example: item.example || ''
                        };
                    } else if (item.type === 'grammar') {
                        url = '/api/grammar';
                        body = {
                            title: item.text,
                            definition: item.meaning,
                            example: item.example || ''
                        };
                    }
                    
                    const res = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(body)
                    });
                    const data = await res.json();
                    
                    if (data.success) {
                        item.inVocab = true;
                        item.newlyAdded = true;
                        item.vocabInfo = {
                            id: data.id,
                            type: item.type,
                            meaning: item.meaning
                        };
                        console.log(`[批量填写] 已入库: ${item.text} (${item.type})`);
                    } else {
                        console.error(`[批量填写] 入库失败: ${item.text}`, data.error);
                        // 即使入库失败也继续，因为可能是重复
                        item.inVocab = true;  // 标记为已处理
                    }
                }
                
                // 3. 更新 allItems 中对应的项
                for (const filled of filledItems) {
                    const found = ctx.allItems.find(it => it.text === filled.text && it.type === filled.type);
                    if (found) {
                        Object.assign(found, filled);
                    }
                }
                
                // 4. 保存替换规则
                closeModal('batchFillModal');
                await saveReplaceRuleV2(ctx.originalText, ctx.itemType, ctx.id, ctx.allItems);
                
            } catch (e) {
                console.error('批量填写保存失败:', e);
                showToast('保存失败: ' + e.message, 'error');
            }
        }

        /**
         * 处理下一个需要填写含义的词条
         */
        function processNextReplaceItem() {
            // 清除模糊匹配的编辑提示（如果存在）
            const existingInfo = document.getElementById('matchEditInfo');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            if (!window._pendingReplaceItems || window._pendingReplaceIndex >= window._pendingReplaceItems.length) {
                saveReplaceRule(
                    window._replaceOriginalText,
                    window._replaceItemType,
                    window._replaceItemId,
                    window._replaceSelected
                );
                return;
            }
            
            const item = window._pendingReplaceItems[window._pendingReplaceIndex];
            const total = window._pendingReplaceItems.length;
            const current = window._pendingReplaceIndex + 1;
            
            // 设置编辑弹窗
            document.getElementById('editItemId').value = '';
            document.getElementById('editItemType').value = item.type;
            document.getElementById('editOriginalText').textContent = item.text;
            document.getElementById('editTargetType').value = item.type;
            document.getElementById('editCategory').value = '';
            document.getElementById('editPhonetic').value = '';
            document.getElementById('editPos').value = '';
            document.getElementById('editMeaning').value = '';
            document.getElementById('editExample').value = '';
            
            document.getElementById('vocabFields').style.display = item.type === 'grammar' ? 'none' : 'block';
            document.getElementById('grammarFields').style.display = item.type === 'grammar' ? 'block' : 'none';
            
            document.querySelector('#editModal .modal-header h2').textContent = 
                `✎ 填写含义 (${current}/${total})`;
            // v7.0: excludeBtn 已删除
            
            window._currentReplaceItem = item;
            document.getElementById('editModal').classList.add('active');
        }

        /**
         * 保存替换规则到替换库 v7.0 - 使用 JSON 格式
         */
        async function saveReplaceRuleV2(originalText, itemType, id, selected) {
            try {
                // v7.0: 构建 target_items JSON
                const targetItems = selected.map(item => ({
                    text: item.text,
                    type: item.type,
                    id: item.vocabInfo?.id || null,
                    source: item.vocabInfo?.id ? 'vocabulary' : 'user_input',
                    meaning: item.meaning || item.vocabInfo?.meaning || '',
                    example: item.example || ''
                }));
                
                // 1. 保存替换规则到 matching.db
                const res = await fetch(MATCHING_DICT_API + '/rules', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_text: originalText,
                        original_type: itemType,
                        action: 'replace',
                        target_text: JSON.stringify(targetItems),  // v7.0: JSON 格式
                        notes: `替换为 ${selected.length} 项: ${selected.map(s => s.text).join(', ')}`,
                        created_by: 'admin'
                    })
                });
                const data = await res.json();
                
                if (!data.success) {
                    showToast(data.error || '保存替换规则失败', 'error');
                    return;
                }
                
                // 2. 标记原记录为已处理
                if (id) {
                    await fetch(API_BASE + '/unmatched/' + id + '/ignore', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            reviewedBy: 'admin',
                            notes: `已替换为: ${selected.map(s => s.text).join(', ')}`
                        })
                    });
                }
                
                // 3. 统计入库情况
                const existCount = selected.filter(s => s.inVocab && s.vocabInfo && !s.newlyAdded).length;
                const newCount = selected.filter(s => s.newlyAdded).length;
                
                // 4. 显示详细成功信息
                let successMsg = `✅ 替换成功！\n\n`;
                successMsg += `📦 替换规则已保存\n`;
                successMsg += `   "${originalText.substring(0, 25)}${originalText.length > 25 ? '...' : ''}"\n`;
                successMsg += `   → ${selected.map(s => s.text).join(', ')}\n\n`;
                
                if (existCount > 0) {
                    successMsg += `📚 词库已有：${existCount} 项（直接关联）\n`;
                }
                if (newCount > 0) {
                    successMsg += `✨ 新增入库：${newCount} 项\n`;
                }
                
                alert(successMsg);
                
                // 5. 清理状态
                window._pendingReplaceItems = null;
                window._pendingReplaceIndex = 0;
                window._replaceOriginalText = null;
                window._replaceItemType = null;
                window._replaceItemId = null;
                window._replaceSelected = null;
                window._currentReplaceItem = null;
                window._batchFillContext = null;
                
                closeModal('matchModal');
                closeModal('editModal');
                closeModal('batchFillModal');
                
                document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                // v7.0: excludeBtn 已删除
                
                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                loadPendingUnmatched();
                
            } catch (e) {
                console.error('保存替换规则失败:', e);
                showToast('保存失败: ' + e.message, 'error');
            }
        }
        
        // 保留旧函数兼容性
        async function saveReplaceRule(originalText, itemType, id, selected) {
            return saveReplaceRuleV2(originalText, itemType, id, selected);
        }

        // 保留旧函数兼容性
        function previewMatch() { }
        function selectVocabMatch() { }
        function executeMatch() { executeMatchNew(); }
        function toggleMatchOption() { }
        function addCustomPhrase() { }
        function updateMatchSelection() { }
        
        // ============================================
        // v6.0: 转为语法功能
        // ============================================
        
        /**
         * 打开转为语法弹窗
         */
        function openToGrammarModal() {
            const id = document.getElementById('editItemId').value;
            const originalText = document.getElementById('editOriginalText').textContent;
            const itemType = document.getElementById('editItemType').value;

            document.getElementById('grammarItemId').value = id;
            document.getElementById('grammarItemType').value = itemType;
            document.getElementById('grammarOriginalText').textContent = originalText;
            document.getElementById('grammarSearchInput').value = '';
            
            // 重置状态
            document.getElementById('grammarSearchResults').style.display = 'none';
            document.getElementById('grammarSelected').style.display = 'none';
            document.getElementById('grammarNewForm').style.display = 'none';
            document.getElementById('grammarSelectedId').value = '';
            
            // v2.0: 重置预览区域
            document.getElementById('grammarFullPreview').style.display = 'none';
            document.getElementById('previewToggleBtn').textContent = '📖 展开详情';
            window._selectedGrammar = null;
            
            // 预填 AI 生成的内容（如果有）
            const aiContent = document.getElementById('editAiContent');
            const aiMeaning = document.getElementById('editMeaning').value;
            const aiExample = document.getElementById('editExample').value;
            
            if (aiMeaning || aiExample) {
                const aiTextDiv = document.getElementById('grammarAiText');
                aiTextDiv.innerHTML = `
                    ${aiMeaning ? `<div>含义：${escapeHtml(aiMeaning)}</div>` : ''}
                    ${aiExample ? `<div>例句：${escapeHtml(aiExample)}</div>` : ''}
                `;
                document.getElementById('grammarAiContent').style.display = 'block';
                
                // 预填新建表单
                document.getElementById('grammarNewDefinition').value = aiMeaning || '';
                document.getElementById('grammarNewExample').value = aiExample || '';
                document.getElementById('grammarNewStructure').value = originalText;
            } else {
                document.getElementById('grammarAiContent').style.display = 'none';
                document.getElementById('grammarNewDefinition').value = '';
                document.getElementById('grammarNewExample').value = '';
                document.getElementById('grammarNewStructure').value = originalText;
            }
            
            document.getElementById('grammarNewTitle').value = '';
            document.getElementById('grammarNewCategory').value = '';
            document.getElementById('grammarNewKeywords').value = '';
            
            document.getElementById('toGrammarModal').classList.add('active');
        }
        
        /**
         * 搜索语法库
         */
        window.searchGrammarLib = async function searchGrammarLib() {
            const keyword = document.getElementById('grammarSearchInput').value.trim();
            
            if (!keyword) {
                showToast('请输入搜索关键词', 'error');
                return;
            }
            
            try {
                const res = await fetch('/api/grammar/search?keyword=' + encodeURIComponent(keyword));
                const data = await res.json();
                
                const resultsDiv = document.getElementById('grammarSearchResults');
                const listDiv = document.getElementById('grammarResultsList');
                const newFormDiv = document.getElementById('grammarNewForm');
                const selectedDiv = document.getElementById('grammarSelected');
                
                if (data.success && data.data && data.data.length > 0) {
                    // 有搜索结果
                    resultsDiv.style.display = 'block';
                    newFormDiv.style.display = 'none';
                    selectedDiv.style.display = 'none';
                    
                    // 更新固定按钮的关键词
                    document.getElementById('grammarCreateNewKeyword').textContent = keyword;
                    
                    listDiv.innerHTML = data.data.map(g => `
                        <div onclick="selectGrammar(${g.id}, '${escapeJs(g.title)}', '${escapeJs(g.definition || '')}')" 
                             style="padding: 12px 16px; border-bottom: 1px solid #f3f4f6; cursor: pointer; transition: background 0.1s;"
                             onmouseover="this.style.background='#f3e8ff'" onmouseout="this.style.background='white'">
                            <div style="font-weight: 600; color: #5b21b6;">${escapeHtml(g.title)}</div>
                            <div style="font-size: 13px; color: #666; margin-top: 4px;">${escapeHtml(g.definition || '暂无定义')}</div>
                            ${g.category ? `<span style="font-size: 11px; background: #ede9fe; color: #6d28d9; padding: 2px 8px; border-radius: 4px; margin-top: 4px; display: inline-block;">${escapeHtml(g.category)}</span>` : ''}
                        </div>
                    `).join('');
                    
                    showToast(`找到 ${data.data.length} 个相关语法`, 'success');
                } else {
                    // 没有搜索结果，显示新建表单
                    resultsDiv.style.display = 'none';
                    selectedDiv.style.display = 'none';
                    newFormDiv.style.display = 'block';
                    
                    // 预填标题为搜索词
                    document.getElementById('grammarNewTitle').value = keyword;
                    
                    showToast('未找到相关语法，请填写信息新建', 'warning');
                }
            } catch (e) {
                console.error('搜索语法库失败:', e);
                showToast('搜索失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 选择已有语法 - v2.0 增强
         */
        function selectGrammar(id, title, definition) {
            document.getElementById('grammarSelectedId').value = id;
            document.getElementById('grammarSelectedTitle').textContent = title;
            document.getElementById('grammarSelectedDef').textContent = definition || '暂无定义';
            
            document.getElementById('grammarSearchResults').style.display = 'none';
            document.getElementById('grammarNewForm').style.display = 'none';
            document.getElementById('grammarSelected').style.display = 'block';
            
            // v2.0: 加载完整预览
            loadGrammarPreview(id);
            
            showToast('已选择：' + title, 'success');
        }
        
        /**
         * 确认转为语法 - v2.0 增强（支持子话题追加）
         */
        async function executeToGrammar() {
            const id = document.getElementById('grammarItemId').value;
            const originalText = document.getElementById('grammarOriginalText').textContent;
            const originalType = document.getElementById('grammarItemType').value;
            const selectedId = document.getElementById('grammarSelectedId').value;
            
            let targetGrammarId = null;
            let targetGrammarTitle = null;
            let isNewGrammar = false;
            
            // v2.0: 收集当前编辑的内容（作为子话题）
            const subTopicContent = {
                title: originalText,
                source_type: 'unmatched',
                source_id: id ? parseInt(id) : null,
                definition: document.getElementById('editDefinition')?.value || 
                           document.getElementById('editMeaning')?.value || '',
                structure: document.getElementById('editStructure')?.value || '',
                usage: document.getElementById('editUsage')?.value?.split('\n').filter(s => s.trim()) || [],
                examples: document.getElementById('editExamples')?.value?.split('\n').filter(s => s.trim()) || 
                          (document.getElementById('editExample')?.value ? [document.getElementById('editExample').value] : []),
                mistakes: document.getElementById('editMistakes')?.value?.split('\n').filter(s => s.trim()) || []
            };
            
            // 情况 A：选择了已有语法
            if (selectedId) {
                targetGrammarId = parseInt(selectedId);
                targetGrammarTitle = document.getElementById('grammarSelectedTitle').textContent;
                isNewGrammar = false;
                
                // v2.0: 追加子话题
                try {
                    const subTopicRes = await fetch('/api/grammar/' + targetGrammarId + '/sub-topic', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(subTopicContent)
                    });
                    const subTopicData = await subTopicRes.json();
                    
                    if (!subTopicData.success) {
                        // 如果是因为已存在，只是警告，不阻止继续
                        if (subTopicData.error === '该子话题已存在') {
                            console.warn('[转为语法] 子话题已存在，跳过追加');
                        } else {
                            showToast('追加子话题失败: ' + subTopicData.error, 'error');
                            return;
                        }
                    } else {
                        console.log(`[转为语法] 子话题已追加: "${originalText}" → "${targetGrammarTitle}" (第${subTopicData.subTopicIndex + 1}个)`);
                    }
                } catch (e) {
                    console.error('追加子话题失败:', e);
                    // 不阻止继续，因为匹配规则可能更重要
                }
            }
            // 情况 B：新建语法
            else if (document.getElementById('grammarNewForm').style.display !== 'none') {
                const title = document.getElementById('grammarNewTitle').value.trim();
                const definition = document.getElementById('grammarNewDefinition').value.trim();
                const category = document.getElementById('grammarNewCategory').value;
                const structure = document.getElementById('grammarNewStructure').value.trim();
                const keywordsStr = document.getElementById('grammarNewKeywords').value.trim();
                const example = document.getElementById('grammarNewExample').value.trim();
                
                if (!title) {
                    showToast('请填写语法标题', 'error');
                    return;
                }
                if (!definition) {
                    showToast('请填写定义说明', 'error');
                    return;
                }
                
                // 1️⃣ 保存新语法到语法库
                const keywords = keywordsStr ? keywordsStr.split(/[,，]/).map(k => k.trim()).filter(k => k) : [title];
                const examples = example ? [example] : [];
                
                // v2.0: 如果原内容不同于标题，直接作为第一个子话题
                const initialSubTopics = (originalText.toLowerCase() !== title.toLowerCase()) ? [subTopicContent] : [];
                
                try {
                    const addRes = await fetch('/api/grammar', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            title,
                            definition,
                            category: category || '其他',
                            structure,
                            keywords,
                            examples,
                            sub_topics: initialSubTopics
                        })
                    });
                    const addData = await addRes.json();
                    
                    if (!addData.success) {
                        showToast('添加语法失败: ' + (addData.error || '未知错误'), 'error');
                        return;
                    }
                    
                    targetGrammarId = addData.id;
                    targetGrammarTitle = title;
                    isNewGrammar = true;
                    
                    console.log('[转为语法] 新语法已添加:', title, '→', targetGrammarId);
                } catch (e) {
                    showToast('添加语法失败: ' + e.message, 'error');
                    return;
                }
            } else {
                showToast('请先搜索并选择语法，或填写新语法信息', 'error');
                return;
            }
            
            // 2️⃣ 保存匹配规则到 matching.db
            try {
                const matchRes = await fetch(MATCHING_DICT_API + '/confirm-match', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        original_text: originalText,
                        original_type: originalType,  // 原类型（如 pattern）
                        target_db: 'grammar.db',
                        target_table: 'grammar',
                        target_id: targetGrammarId,
                        target_text: targetGrammarTitle,
                        created_by: 'admin'
                    })
                });
                const matchData = await matchRes.json();
                
                if (!matchData.success) {
                    showToast('保存匹配规则失败: ' + (matchData.error || '未知错误'), 'error');
                    return;
                }
                
                console.log('[转为语法] 匹配规则已保存:', originalText, '→', targetGrammarTitle);
            } catch (e) {
                showToast('保存匹配规则失败: ' + e.message, 'error');
                return;
            }
            
            // 3️⃣ 标记原记录为已处理
            // v6.1: 区分处理匹配记录和未匹配记录
            const wasEditingMatch = !!window._editingMatchId;  // 保存标记，用于后续刷新列表
            
            if (window._editingMatchId) {
                // 情况A：正在编辑模糊匹配记录 → 需要确认匹配
                try {
                    const matchId = window._editingMatchId;
                    await fetch(API_BASE + '/matches/' + matchId + '/confirm', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ reviewedBy: 'admin' })
                    });
                    console.log('[转为语法] 匹配记录已确认:', matchId);
                    
                    // 清理编辑状态
                    window._editingMatchId = null;
                    window._editingMatchData = null;
                } catch (e) {
                    console.warn('确认匹配记录失败:', e);
                }
            } else if (id) {
                // 情况B：正在编辑未匹配记录 → 标记为已忽略
                try {
                    await fetch(API_BASE + '/unmatched/' + id + '/ignore', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            reviewedBy: 'admin',
                            notes: `已转为语法: ${targetGrammarTitle}${isNewGrammar ? '' : ' (作为子话题追加)'}`
                        })
                    });
                    console.log('[转为语法] 未匹配记录已标记:', id);
                } catch (e) {
                    console.warn('标记原记录失败:', e);
                }
            }
            
            // 4️⃣ 显示成功信息
            const shortOriginal = originalText.length > 20 ? originalText.substring(0, 20) + '...' : originalText;
            if (isNewGrammar) {
                showToast(`转换成功！已新增语法「${targetGrammarTitle}」并建立匹配规则`, 'success');
            } else {
                showToast(`转换成功！「${shortOriginal}」已追加到「${targetGrammarTitle}」的子话题中`, 'success');
            }
            
            // 5️⃣ 清理并关闭
            window._selectedGrammar = null;
            closeModal('toGrammarModal');
            closeModal('editModal');
            loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
            // v6.1: 根据编辑类型刷新对应列表
            if (wasEditingMatch) {
                loadPendingMatches();  // 刷新模糊匹配列表
            } else {
                loadPendingUnmatched();  // 刷新未匹配列表
            }
        }
        
        // ============================================
        // v2.0: 转为语法增强功能 - 辅助函数
        // ============================================
        
        /**
         * 切换语法预览展开/折叠
         */
        function toggleGrammarPreview() {
            const previewDiv = document.getElementById('grammarFullPreview');
            const btn = document.getElementById('previewToggleBtn');
            
            if (previewDiv.style.display === 'none') {
                previewDiv.style.display = 'block';
                btn.textContent = '📕 收起详情';
            } else {
                previewDiv.style.display = 'none';
                btn.textContent = '📖 展开详情';
            }
        }
        
        /**
         * 加载并显示目标语法词条的完整信息
         */
        async function loadGrammarPreview(grammarId) {
            try {
                const res = await fetch('/api/grammar/' + grammarId);
                const data = await res.json();
                
                if (!data.success) {
                    console.error('加载语法详情失败');
                    return;
                }
                
                const grammar = data.data;
                
                // 填充基本信息
                const contentDiv = document.getElementById('grammarPreviewContent');
                contentDiv.innerHTML = `
                    <div style="display: grid; gap: 8px; font-size: 13px; color: #374151;">
                        ${grammar.structure ? `<div><strong>结构：</strong>${escapeHtml(grammar.structure)}</div>` : ''}
                        ${grammar.usage && grammar.usage.length > 0 ? `<div><strong>用法：</strong>${grammar.usage.map(u => escapeHtml(u)).join('；')}</div>` : ''}
                        ${grammar.examples && grammar.examples.length > 0 ? `<div><strong>例句：</strong>${grammar.examples.map(e => escapeHtml(e)).join('；')}</div>` : ''}
                        ${grammar.mistakes && grammar.mistakes.length > 0 ? `<div><strong>易错点：</strong>${grammar.mistakes.map(m => escapeHtml(m)).join('；')}</div>` : ''}
                        ${grammar.category ? `<div><strong>分类：</strong><span style="background:#ede9fe;color:#6d28d9;padding:2px 8px;border-radius:4px;">${escapeHtml(grammar.category)}</span></div>` : ''}
                    </div>
                `;
                
                // 填充子话题列表
                const subTopics = grammar.sub_topics || [];
                document.getElementById('subTopicsCount').textContent = subTopics.length;
                
                const container = document.getElementById('subTopicsContainer');
                if (subTopics.length === 0) {
                    container.innerHTML = '<div style="color: #9ca3af; font-size: 12px; padding: 8px;">暂无相关知识点</div>';
                } else {
                    container.innerHTML = subTopics.map((st, idx) => `
                        <div style="background: white; padding: 10px; border-radius: 6px; margin-bottom: 6px; border: 1px solid #e5e7eb;">
                            <div style="font-weight: 500; color: #374151; margin-bottom: 4px;">${idx + 1}. ${escapeHtml(st.title)}</div>
                            <div style="font-size: 12px; color: #6b7280;">${escapeHtml(st.definition || '暂无定义')}</div>
                            ${st.added_at ? `<div style="font-size: 11px; color: #9ca3af; margin-top: 4px;">添加于 ${formatTime(st.added_at)}</div>` : ''}
                        </div>
                    `).join('');
                }
                
                // 填充即将追加的内容预览
                updatePendingSubTopicPreview();
                
                // 保存当前语法信息到全局变量，供后续使用
                window._selectedGrammar = grammar;
                
            } catch (e) {
                console.error('加载语法预览失败:', e);
            }
        }
        
        /**
         * 更新即将追加的子话题预览
         */
        function updatePendingSubTopicPreview() {
            const originalText = document.getElementById('grammarOriginalText').textContent;
            
            // 从编辑弹窗获取当前编辑的内容
            const definition = document.getElementById('editDefinition')?.value || 
                               document.getElementById('editMeaning')?.value || '';
            const structure = document.getElementById('editStructure')?.value || '';
            const usage = document.getElementById('editUsage')?.value || '';
            const examples = document.getElementById('editExamples')?.value || 
                             document.getElementById('editExample')?.value || '';
            const mistakes = document.getElementById('editMistakes')?.value || '';
            
            const previewDiv = document.getElementById('pendingSubTopicPreview');
            previewDiv.innerHTML = `
                <div style="font-weight: 500; color: #78350f; margin-bottom: 6px;">「${escapeHtml(originalText)}」</div>
                ${definition ? `<div>定义：${escapeHtml(definition.substring(0, 100))}${definition.length > 100 ? '...' : ''}</div>` : ''}
                ${structure ? `<div>结构：${escapeHtml(structure)}</div>` : ''}
                ${usage ? `<div>用法：${escapeHtml(usage.split('\\n')[0])}${usage.includes('\\n') ? '...' : ''}</div>` : ''}
                ${examples ? `<div>例句：${escapeHtml(examples.split('\\n')[0])}${examples.includes('\\n') ? '...' : ''}</div>` : ''}
                ${!definition && !structure && !usage && !examples ? '<div style="color: #9ca3af;">（暂无内容，将只保存标题）</div>' : ''}
            `;
        }
        
        /**
         * 显示新建语法表单（从搜索结果点击"新建"时调用）
         */
        function showNewGrammarForm() {
            const keyword = document.getElementById('grammarSearchInput').value.trim();
            
            // 隐藏搜索结果，显示新建表单
            document.getElementById('grammarSearchResults').style.display = 'none';
            document.getElementById('grammarSelected').style.display = 'none';
            document.getElementById('grammarNewForm').style.display = 'block';
            
            // 预填标题为搜索词
            document.getElementById('grammarNewTitle').value = keyword;
            
            showToast('请填写新语法信息', 'info');
        }
        
        /**
         * 快速新建语法词条
         */
        async function quickCreateGrammar() {
            const keyword = document.getElementById('grammarSearchInput').value.trim();
            
            if (!keyword) {
                showToast('请先输入语法关键词', 'error');
                return;
            }
            
            // 弹出简化的确认框
            const title = prompt('请输入语法词条标题：', keyword);
            if (!title) return;
            
            const definition = prompt('请输入简要定义（可留空后续补充）：', '');
            if (definition === null) return;  // 用户取消
            
            try {
                const res = await fetch('/api/grammar', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        title: title.trim(),
                        definition: definition.trim() || '待补充',
                        keywords: [title.trim()],
                        category: '其他'
                    })
                });
                const data = await res.json();
                
                if (data.success) {
                    showToast(`语法词条「${title}」创建成功！`, 'success');
                    
                    // 自动选中新创建的语法
                    selectGrammar(data.id, title, definition || '待补充');
                    
                    // 隐藏新建表单
                    document.getElementById('grammarNewForm').style.display = 'none';
                } else {
                    showToast('创建失败: ' + (data.error || '未知错误'), 'error');
                }
            } catch (e) {
                showToast('创建失败: ' + e.message, 'error');
            }
        }
        
        /**
         * 处理下一个新单词（打开编辑弹窗）
         * v5.6: 预填AI生成的内容
         */
        function processNextNewWord() {
            // 清除模糊匹配的编辑提示（如果存在）
            const existingInfo = document.getElementById('matchEditInfo');
            if (existingInfo) {
                existingInfo.remove();
            }
            
            if (!window._pendingNewWords || window._pendingNewWordsIndex >= window._pendingNewWords.length) {
                // 全部处理完成，清理状态
                window._pendingNewWords = null;
                window._pendingNewWordsIndex = 0;
                window._aiGeneratedContent = null;
                showToast('所有单词处理完成！', 'success');
                loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                loadPendingUnmatched();
                return;
            }
            
            const word = window._pendingNewWords[window._pendingNewWordsIndex];
            window._pendingNewWordsIndex++;
            
            const remaining = window._pendingNewWords.length - window._pendingNewWordsIndex;
            
            // 打开编辑弹窗，预填单词
            document.getElementById('editItemId').value = '';  // 新建模式
            document.getElementById('editItemType').value = 'word';
            document.getElementById('editOriginalText').textContent = word;
            document.getElementById('editTargetType').value = 'word';
            document.getElementById('editCategory').value = '';
            
            // 显示词汇字段
            document.getElementById('vocabFields').style.display = 'block';
            document.getElementById('grammarFields').style.display = 'none';
            document.getElementById('editPhonetic').value = '';
            
            // v5.6: 预填AI生成的内容
            const aiContent = window._aiGeneratedContent || {};
            document.getElementById('editPos').value = aiContent.pos || '';
            document.getElementById('editMeaning').value = aiContent.meaning || '';
            document.getElementById('editExample').value = aiContent.example || '';
            
            console.log(`[新建单词] ${word} - 预填AI内容:`, aiContent);
            
            // 修改弹窗标题提示还有多少个待处理
            const modalHeader = document.querySelector('#editModal .modal-header h2');
            if (remaining > 0) {
                modalHeader.textContent = `✎ 新建单词 (还有 ${remaining} 个待处理)`;
            } else {
                modalHeader.textContent = `✎ 新建单词`;
            }
            
            // 隐藏排除按钮（新建模式不需要）
            // v7.0: excludeBtn 已删除
            
            // 显示弹窗
            document.getElementById('editModal').classList.add('active');
        }
        
        // ============================================
        // 清空数据功能
        // ============================================
        
        function openClearModal() {
            document.getElementById('clearConfirmInput').value = '';
            document.getElementById('clearModal').classList.add('active');
        }
        
        async function executeClear() {
            const input = document.getElementById('clearConfirmInput').value.trim();
            
            if (input !== '确认清除') {
                showToast('请输入正确的确认文字：确认清除', 'error');
                return;
            }
            
            try {
                const res = await fetch(API_BASE + '/clear-all', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ confirm: '确认清除' })
                });
                const data = await res.json();
                
                if (data.success) {
                    // v5.2 修复：显示完整的删除数量（包括任务）
                    const total = (data.deleted.matched || 0) + (data.deleted.unmatched || 0) + (data.deleted.tasks || 0);
                    showToast(`清空成功！已删除 ${data.deleted.tasks || 0} 个任务、${(data.deleted.matched || 0) + (data.deleted.unmatched || 0)} 条记录`, 'success');
                    closeModal('clearModal');
                    loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                    loadTasks();
                    loadPendingMatches();
                    loadPendingUnmatched();
                } else {
                    showToast(data.error || '清空失败', 'error');
                }
            } catch (e) {
                showToast('清空失败: ' + e.message, 'error');
            }
        }
        
        // ============================================
        // 工具函数
        // ============================================
        
        function closeModal(id, skipCheck = false) {
            document.getElementById(id).classList.remove('active');
            
            // v5.5: 关闭编辑弹窗时清理新建模式状态
            if (id === 'editModal') {
                // 恢复弹窗标题
                document.querySelector('#editModal .modal-header h2').textContent = '✎ 编辑数据';
                // 恢复排除按钮
                // v7.0: excludeBtn 已删除
                
                // 如果是用户手动关闭（不是程序调用），且还有待处理的单词，询问是否继续
                if (!skipCheck && window._pendingNewWords && window._pendingNewWordsIndex < window._pendingNewWords.length) {
                    const remaining = window._pendingNewWords.length - window._pendingNewWordsIndex;
                    if (confirm(`还有 ${remaining} 个单词待处理，是否继续？`)) {
                        setTimeout(() => processNextNewWord(), 100);
                    } else {
                        // 用户取消，清理状态
                        window._pendingNewWords = null;
                        window._pendingNewWordsIndex = 0;
                        loadStats();
        fetch('/api/processing-stats').then(res => res.json()).then(data => {
            const el = document.getElementById('badgeExactMatches');
            if (el) { el.textContent = data.exactMatch || 0; el.style.display = ''; }
        });
                        loadPendingUnmatched();
                    }
                }
            }
        }
        
        function showToast(msg, type) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.className = 'toast ' + type + ' show';
            setTimeout(() => t.classList.remove('show'), 3000);
        }
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // v3.0: 转义JavaScript字符串
        function escapeJs(text) {
            if (!text) return '';
            return text
                .replace(/\\/g, '\\\\')
                .replace(/'/g, "\\'")
                .replace(/"/g, '\\"')
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r');
        }
        
        /**
         * 格式化时间 - v5.4 强制使用北京时间（UTC+8）
         * 数据库存储的是 UTC 时间，直接加8小时转为北京时间
         */
        function formatTime(dateStr) {
            if (!dateStr) return '';
            
            let date;
            
            if (dateStr.includes('T') || dateStr.includes('Z')) {
                date = new Date(dateStr);
            } else {
                // 数据库存的是 UTC 时间
                date = new Date(dateStr.replace(' ', 'T') + 'Z');
            }
            
            if (isNaN(date.getTime())) {
                return dateStr;
            }
            
            // 强制使用北京时间（UTC+8）
            const beijingTime = new Date(date.getTime() + 8 * 60 * 60 * 1000);
            
            const month = String(beijingTime.getUTCMonth() + 1).padStart(2, '0');
            const day = String(beijingTime.getUTCDate()).padStart(2, '0');
            const hour = String(beijingTime.getUTCHours()).padStart(2, '0');
            const minute = String(beijingTime.getUTCMinutes()).padStart(2, '0');
            
            return `${month}/${day} ${hour}:${minute}`;
        }
        
        function getTypeLabel(type) {
            const labels = {
                'word': '单词',
                'phrase': '短语',
                'pattern': '句型',
                'grammar': '语法'
            };
            return labels[type] || type;
        }
        
        function getStatusLabel(status) {
            const labels = {
                'pending': '待完善',
                'edited': '已编辑',
                'imported': '已入库',
                'ignored': '已忽略'
            };
            return labels[status] || status;
        }
        
        function formatAIContent(content) {
            if (!content) return '';
            const parts = [];
            if (content.meaning) parts.push(`含义: ${content.meaning}`);
            if (content.definition) parts.push(`定义: ${content.definition}`);
            if (content.example) parts.push(`例句: ${content.example}`);
            if (content.structure) parts.push(`结构: ${content.structure}`);
            if (content.phonetic) parts.push(`音标: ${content.phonetic}`);
            if (content.pos) parts.push(`词性: ${content.pos}`);
            return parts.join(' · ') || JSON.stringify(content).substring(0, 100);
        }
    </script>
<script>
// 加载统计数据
fetch('/api/processing-stats')
    .then(res => res.json())
    .then(data => {
        const exactCountEl = document.getElementById('exact-match-count');
        if (exactCountEl) {
            exactCountEl.textContent = data.exactMatch || 0;
        }
    })
    .catch(err => console.error('加载统计失败:', err));
</script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    fetch('/api/processing-stats')
        .then(res => res.json())
        .then(data => {
            const badge = document.getElementById('badgeExactMatches');
            if (badge) {
                badge.textContent = data.exactMatch || 0;
                badge.style.display = '';
            }
        });
});
</script>
<script>
// 页面加载时更新精准匹配数字
document.addEventListener('DOMContentLoaded', function() {
    console.log('开始加载精准匹配数据...');
    fetch('/api/processing-stats')
        .then(res => res.json())
        .then(data => {
            console.log('精准匹配API返回:', data);
            const badge = document.getElementById('badgeExactMatches');
            if (badge && data.exactMatch) {
                badge.textContent = data.exactMatch;
                badge.style.display = '';
                console.log('精准匹配数字已更新:', data.exactMatch);
            }
        })
        .catch(err => console.error('加载精准匹配失败:', err));
});

// ============================================
// 点击外部关闭搜索结果框
// ============================================
document.addEventListener('click', function(e) {
    // 获取所有搜索结果框
    const searchResults = [
        { input: 'vocabSearchInput', results: 'vocabSearchResults' },
        { input: 'grammarSearchInputMatch', results: 'grammarSearchResultsMatch' },
        { input: 'replaceSearchInput', results: 'replaceSearchResults' }
    ];
    
    searchResults.forEach(item => {
        const inputElem = document.getElementById(item.input);
        const resultsElem = document.getElementById(item.results);
        
        if (!inputElem || !resultsElem) return;
        
        // 如果点击的不是输入框、搜索按钮或结果框本身，则关闭
        if (!inputElem.contains(e.target) && 
            !resultsElem.contains(e.target) &&
            e.target.textContent !== '🔍 搜索' &&
            !e.target.closest('.btn-sm')) {
            if (resultsElem.style.display === 'block') {
                resultsElem.style.display = 'none';
                console.log(`[搜索框] 自动关闭: ${item.results}`);
            }
        }
    });
});

</script>

<!-- 精准匹配内容区域 -->
</script>


<script>
// ============================================
// 精准匹配功能 - v5.4.3 带分页版本
// ============================================

// 分页状态
const exactMatchesState = {
    currentPage: 1,
    pageSize: 50,
    total: 0
};

/**
 * 加载精准匹配列表（带分页）
 */
function loadExactMatches(page = 1) {
    console.log(`[精准匹配] 加载第 ${page} 页，每页 ${exactMatchesState.pageSize} 条`);
    const container = document.getElementById('exactMatchesContainer');
    
    if (!container) {
        console.error('[精准匹配] 找不到容器');
        return;
    }
    
    exactMatchesState.currentPage = page;
    const offset = (page - 1) * exactMatchesState.pageSize;
    
    container.innerHTML = '<div class="loading">加载中...</div>';
    
    fetch(`/api/processing-log/exact-matches?limit=${exactMatchesState.pageSize}&offset=${offset}`)
        .then(res => {
            console.log('[精准匹配] API响应状态:', res.status);
            if (!res.ok) {
                throw new Error(`HTTP ${res.status}: ${res.statusText}`);
            }
            return res.json();
        })
        .then(data => {
            console.log('[精准匹配] 收到数据:', data);
            
            if (!data.success) {
                throw new Error(data.error || '请求失败');
            }
            
            exactMatchesState.total = data.total || 0;
            
            if (data.items && data.items.length > 0) {
                let html = '<div style="padding:16px;">';
                
                data.items.forEach((item, index) => {
                    const date = new Date(item.created_at);
                    const timeStr = date.toLocaleString('zh-CN', {
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    const typeIcon = {
                        'word': '📝',
                        'phrase': '💬',
                        'pattern': '🔤',
                        'grammar': '📚'
                    }[item.item_type] || '📄';
                    
                    const rowNumber = offset + index + 1;
                    
                    html += `
                        <div style="padding:14px; margin-bottom:10px; background:white; border:1px solid #e5e5e5; border-radius:8px; transition: all 0.2s;">
                            <div style="display:flex; justify-content:space-between; align-items:start; margin-bottom:8px;">
                                <div style="flex:1;">
                                    <div style="font-weight:600; font-size:15px; color:#1a1a1a; margin-bottom:4px;">
                                        <span style="color:#9ca3af; font-size:13px; margin-right:8px;">#${rowNumber}</span>
                                        ${typeIcon} ${item.original_text}
                                    </div>
                                    <div style="color:#059669; font-size:14px; margin-bottom:4px;">
                                        → ${item.matched_text || '(无匹配文本)'}
                                    </div>
                                </div>
                                <div style="background:#10b981; color:white; padding:4px 10px; border-radius:12px; font-size:12px; font-weight:600;">
                                    ${(item.match_score * 100).toFixed(0)}%
                                </div>
                            </div>
                            <div style="display:flex; gap:16px; color:#6b7280; font-size:12px; padding-top:8px; border-top:1px solid #f3f4f6;">
                                <span>📁 ${item.item_type}</span>
                                <span>🗂️ ${item.source_db}.${item.source_table}</span>
                                ${item.file_name ? `<span>📄 ${item.file_name}</span>` : ''}
                                <span>🕒 ${timeStr}</span>
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
                
                // 添加分页控件
                html += renderPagination();
                
                container.innerHTML = html;
                console.log(`[精准匹配] ✅ 已显示第 ${page} 页，${data.items.length} 条记录（共 ${data.total} 条）`);
                
            } else {
                container.innerHTML = `
                    <div class="empty-state">
                        <h3>📭 暂无精准匹配数据</h3>
                        <p style="color:#6b7280; margin-top:8px;">
                            处理新任务后，系统会自动记录100%匹配的词条
                        </p>
                    </div>
                `;
                console.log('[精准匹配] ℹ️ 暂无数据');
            }
        })
        .catch(err => {
            console.error('[精准匹配] ❌ 加载失败:', err);
            container.innerHTML = `
                <div class="empty-state">
                    <h3>❌ 加载失败</h3>
                    <p style="color:#dc2626; margin-top:8px;">${err.message}</p>
                    <button class="btn btn-primary" onclick="loadExactMatches(${page})" style="margin-top:16px;">
                        🔄 重新加载
                    </button>
                </div>
            `;
        });
}

/**
 * 渲染分页控件
 */
function renderPagination() {
    const totalPages = Math.ceil(exactMatchesState.total / exactMatchesState.pageSize);
    const currentPage = exactMatchesState.currentPage;
    
    if (totalPages <= 1) {
        return `
            <div style="padding:12px 16px; border-top:1px solid #e5e5e5; color:#6b7280; font-size:13px; text-align:center;">
                共 ${exactMatchesState.total} 条记录
            </div>
        `;
    }
    
    let html = `
        <div style="padding:12px 16px; border-top:1px solid #e5e5e5; display:flex; justify-content:space-between; align-items:center;">
            <div style="color:#6b7280; font-size:13px;">
                显示第 ${(currentPage - 1) * exactMatchesState.pageSize + 1} - ${Math.min(currentPage * exactMatchesState.pageSize, exactMatchesState.total)} 条，共 ${exactMatchesState.total} 条记录
            </div>
            <div style="display:flex; gap:8px; align-items:center;">
                <!-- 每页显示数量 -->
                <select onchange="changePageSize(this.value)" style="padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; font-size:13px; cursor:pointer;">
                    <option value="50" ${exactMatchesState.pageSize === 50 ? 'selected' : ''}>50条/页</option>
                    <option value="100" ${exactMatchesState.pageSize === 100 ? 'selected' : ''}>100条/页</option>
                    <option value="200" ${exactMatchesState.pageSize === 200 ? 'selected' : ''}>200条/页</option>
                    <option value="9999" ${exactMatchesState.pageSize === 9999 ? 'selected' : ''}>全部</option>
                </select>
                
                <!-- 上一页 -->
                <button 
                    onclick="loadExactMatches(${currentPage - 1})" 
                    ${currentPage === 1 ? 'disabled' : ''}
                    style="padding:6px 12px; border:1px solid #d1d5db; border-radius:6px; background:white; cursor:${currentPage === 1 ? 'not-allowed' : 'pointer'}; font-size:13px; color:#374151;">
                    ← 上一页
                </button>
                
                <!-- 页码 -->
                <div style="display:flex; gap:4px;">
    `;
    
    // 生成页码按钮（最多显示7个）
    let startPage = Math.max(1, currentPage - 3);
    let endPage = Math.min(totalPages, startPage + 6);
    if (endPage - startPage < 6) {
        startPage = Math.max(1, endPage - 6);
    }
    
    // 第一页
    if (startPage > 1) {
        html += `
            <button onclick="loadExactMatches(1)" style="padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:white; cursor:pointer; font-size:13px; min-width:36px;">1</button>
        `;
        if (startPage > 2) {
            html += `<span style="padding:6px 4px; color:#9ca3af;">...</span>`;
        }
    }
    
    // 中间页码
    for (let i = startPage; i <= endPage; i++) {
        const isActive = i === currentPage;
        html += `
            <button 
                onclick="loadExactMatches(${i})" 
                style="padding:6px 10px; border:1px solid ${isActive ? '#2563eb' : '#d1d5db'}; border-radius:6px; background:${isActive ? '#eff6ff' : 'white'}; color:${isActive ? '#2563eb' : '#374151'}; cursor:pointer; font-size:13px; font-weight:${isActive ? '600' : '400'}; min-width:36px;">
                ${i}
            </button>
        `;
    }
    
    // 最后一页
    if (endPage < totalPages) {
        if (endPage < totalPages - 1) {
            html += `<span style="padding:6px 4px; color:#9ca3af;">...</span>`;
        }
        html += `
            <button onclick="loadExactMatches(${totalPages})" style="padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:white; cursor:pointer; font-size:13px; min-width:36px;">${totalPages}</button>
        `;
    }
    
    html += `
                </div>
                
                <!-- 下一页 -->
                <button 
                    onclick="loadExactMatches(${currentPage + 1})" 
                    ${currentPage === totalPages ? 'disabled' : ''}
                    style="padding:6px 12px; border:1px solid #d1d5db; border-radius:6px; background:white; cursor:${currentPage === totalPages ? 'not-allowed' : 'pointer'}; font-size:13px; color:#374151;">
                    下一页 →
                </button>
                
                <!-- 跳转 -->
                <div style="display:flex; align-items:center; gap:6px; margin-left:8px;">
                    <span style="font-size:13px; color:#6b7280;">跳转</span>
                    <input 
                        type="number" 
                        id="jumpToPage" 
                        min="1" 
                        max="${totalPages}" 
                        placeholder="${currentPage}"
                        onkeypress="if(event.key==='Enter') jumpToPage()"
                        style="width:50px; padding:6px 8px; border:1px solid #d1d5db; border-radius:6px; font-size:13px; text-align:center;">
                    <button onclick="jumpToPage()" style="padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:white; cursor:pointer; font-size:13px;">Go</button>
                </div>
            </div>
        </div>
    `;
    
    return html;
}

/**
 * 改变每页显示数量
 */
function changePageSize(newSize) {
    exactMatchesState.pageSize = parseInt(newSize);
    exactMatchesState.currentPage = 1; // 重置到第一页
    loadExactMatches(1);
}

/**
 * 跳转到指定页
 */
function jumpToPage() {
    const input = document.getElementById('jumpToPage');
    const page = parseInt(input.value);
    const totalPages = Math.ceil(exactMatchesState.total / exactMatchesState.pageSize);
    
    if (page >= 1 && page <= totalPages) {
        loadExactMatches(page);
    } else {
        alert(`请输入 1-${totalPages} 之间的页码`);
    }
}

// 增强 switchTab 函数
(function() {
    const originalSwitchTab = window.switchTab;
    if (originalSwitchTab) {
        window.switchTab = function(tab) {
            console.log('[switchTab] 切换到:', tab);
            originalSwitchTab.call(this, tab);
            if (tab === 'exact-matches') {
                console.log('[switchTab] 触发精准匹配加载');
                loadExactMatches(1);
            }
        };
        console.log('[精准匹配] switchTab 增强已启用');
    }
})();

console.log('[精准匹配] 模块加载完成 v5.4.3（带分页）');
</script>

</body>
</html>